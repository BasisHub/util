use com.basis.api.admin.BBjAdminFactory
use com.basis.api.admin.BBjAdminBase
use com.basis.api.admin.BBjAdminOpenFile
use java.util.List
use java.util.Iterator
use java.net.InetAddress
use java.util.GregorianCalendar
use java.util.Calendar
use java.io.File
use java.util.LinkedHashMap


class public TB


    field public static BBjFileSystem fileSystem! = bbjapi().getFileSystem() 
    field private static LinkedHashMap deviceList! = #getDeviceList()

    method public static BBjNumber UNT0(BBjString fichier$)
	canal=0
	SETERR UNT_END
	C=UNT; OPEN (C,ERR=UNT_END) fichier$
	fichier$=CVS(FID(C)(9),2)
	CLOSE(C)
	lcan$=CHN
	i=1
	WHILE (i < LEN(LCAN$) )
		canalt=DEC($00$+lcan$(i,2))
		if canalt > 0 then
			fichier0$ = cvs(FID(canalt)(9),2)
			if (fichier$ = fichier0$) then
				canal=canalt
				break
			fi
		fi
		i=i+2
	WEND
	UNT_END:
	methodret canal
    methodend

    method public static BBjNumber DTN(BBjString dateval$, BBjString datemask$)
        seterr DTNJ_err
        prc=tcb(14)
        PRECISION 8


        let dt$=$$, mk$=$$, datemask$=cvs(datemask$,4)

        let x=pos("YYYY"=datemask$)
        if x<>0 then
            let dt$=dt$+dateval$(x,4), mk$=mk$+"%Yl", datemask$(x,4)="xxxx"
        fi

        let x=pos("YY"=datemask$)
        if x<>0 then
            if num(dateval$(x,2))>50 then
                let dt$=dt$+"19"+dateval$(x,2)
            else
                let dt$=dt$+"20"+dateval$(x,2)
            fi
            let mk$=mk$+"%Yl", datemask$(x,2)="xx"
        fi

        let x=pos("DDD"=datemask$)
        if x<>0 then
            mk$=mk$+"%Mz%Dz", datemask$(x,3)="xxx"
            declare GregorianCalendar gc! 
            gc! = new java.util.GregorianCalendar() 
            gc!.set(Calendar.DAY_OF_YEAR,num(dateval$(x,3)))
            gc!.set(Calendar.YEAR,num(dt$))
            dt$=dt$+str(gc!.get(Calendar.MONTH)+1:"00")+str(gc!.get(Calendar.DAY_OF_MONTH))
            goto return_dtn
        fi    


        let x=pos("MM"=datemask$)
        if x<>0 then
            let dt$=dt$+dateval$(x,2), mk$=mk$+"%Mz", datemask$(x,2)="xx"
        else
            let dt$=dt$+"01", mk$=mk$+"%Mz"
        fi

        let x=pos("DD"=datemask$)
        if x<>0 then
            let dt$=dt$+dateval$(x,2), mk$=mk$+"%Dz", datemask$(x,2)="xx"
        else
            let dt$=dt$+"01", mk$=mk$+"%Dz"
        fi

        datedec=0

        let x=pos("HH"=datemask$)
        if x<>0 then
            let datedec=num(dateval$(x,2))/24
        fi

        let x=pos("MI"=datemask$)
        if x<>0 then
            let datedec=datedec+num(dateval$(x,2))/24/60
        fi

                let x=pos("SS"=datemask$)
        if x<>0 then
            let datedec=datedec+num(dateval$(x,2))/24/60/60
        fi

        return_dtn:
        PRECISION prc
        dtn = jul(dt$,mk$)-1721423
        methodret dtn+datedec

        DTNJ_err:
        PRECISION prc
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend



    method public static BBjString NTD(BBjNumber dateval, BBjString datemask$)
REM         seterr NTDJ_err
        declare String datemask!
        datemask!=datemask$


        if dateval=0 then 
            dateval=JUL(0,0,0)-1721423
            datedec=TIM
        else    
            datedec=mod(dateval,1)
            dateval=dateval-datedec
            datedec=datedec*24   
        endif

           let x=pos("YYYY"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Yl"+datemask$(X+4)
        fi

        let x=pos("YY"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Yz"+datemask$(X+2)
        fi

        let x=pos("MM"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Mz"+datemask$(X+2)
        fi

        uppercase=0

        let x=pos("MON"=datemask$)
        if x<>0 then
             mupper=1
             datemask! = datemask$
             let datemask$=datemask!.replaceAll("MON","%Ms")
        fi

        let x=pos("Dy"=datemask$)
        if x<>0 then
             datemask! = datemask$
             let datemask$=datemask!.replaceAll("Dy","%Ds")
        fi

        let x=pos("DY"=datemask$)
        if x<>0 then
             dupper=1
             datemask! = datemask$
             let datemask$=datemask!.replaceAll("DY","%Ds")
        fi


	let x=pos("DDD"=datemask$)
	if x<>0 then
		annee$=TB.NTD(dateval,"YYYY")	
		dateinit=TB.DTN(annee$+"0101","YYYYMMDD")
		quantieme=dateval-dateinit+1
		datemask$=datemask$(1,x-1)+str(quantieme:"000")+datemask$(x+3)
	fi
        let x=pos("DD"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Dz"+datemask$(X+2)
        fi

        let x=pos("HH"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Hz"+datemask$(X+2)
        fi
        let x=pos("MI"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%mz"+datemask$(X+2)
        fi

        let x=pos("SS"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%sz"+datemask$(X+2)
        fi

        let x=pos("SSSSSS"=datemask$)
        if x<>0 then
            datedec$=""
            datedecval=datedec*60*60
            datedecval=mod(datedecval,1)
            datedec=round(datedec-(datedecval/10000),4)

            datemask!=datemask$
            datemask$=datemask!.replaceAll(".SSSSSS","")
            if datedec>0 then 
                datedec$=str(datedecval:".000000")
            endif 

                   fi

        datemask! = datemask$ 
        datemask$ = datemask!.replaceAll("Day","%Dl")

        numDate=num(str(dateval+1721423))

        if datedec>0 
            ntd$=date(numDate,datedec:datemask$)+datedec$
        else  
            ntd$=date(numDate:datemask$)+datedec$
        endif 

                declare String ntd! 
        ntd! = ntd$

        if stbl("!LOCALE")="fr_FR" then 
            if pos("%Ds"=datemask$)>0 then 
                day$=date(numDate:"%Ds") 
                if len(day$)>3 then 
                    nday$=cvs(day$(1,1),4)+day$(2,2)
                    if dupper then nday$=cvs(nday$,4) endif 
                    ntd! = ntd!.replaceAll(day$,nday$)
                endif
            endif 
            if pos("%Ms"=datemask$)>0 then 
                month$=date(numDate:"%Ms") 
                if len(month$)>3 then 
                    nmonth$=cvs(month$(1,1),4)+month$(2,2)
                    if mupper then nmonth$=cvs(nmonth$,4) endif 
                    ntd! = ntd!.replaceAll(month$,nmonth$)
                endif
            endif 

                        if pos("%Dl"=datemask$)>0 then 
                lday$=date(numDate:"%Dl") 
                    nlday$=cvs(lday$(1,1),4)+lday$(2)
                    ntd! = ntd!.replaceAll(lday$,nlday$)
                endif
            endif 

            endif 

        ntd$=ntd!
        return_tnd:
REM         if uppercase then ntd$=cvs(ntd$,4)
        methodret ntd$
        NTDJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err
    methodend

    method public static BBjString CVT(BBjString stringa$, BBjNumber valore)
        seterr CVTJ_err
        if stringa$="" then methodret stringa$ endif 

        comp$=bin(0,8)
        valore$=bin(valore,8)
        if AND(valore$,bin(1,8))>comp$
            let stringa$=tbl(stringa$,$7F$)
        endif 
        if AND(valore$,bin(2,8))>comp$
            stringa$=cvs(stringa$,144)  
        endif
        if AND(valore$,bin(4,8))>comp$
            if len(stringa$)=0 then
                valore=valore-4
            fi
            while POS($20$>stringa$) 
                PP=POS($20$>stringa$)  
                stringa$=stringa$(1,PP-1)+stringa$(PP+1)
            wend  
        endif
        if AND(valore$,bin(8,8))>comp$
            let stringa$=cvs(stringa$,1)
        endif
        if AND(valore$,bin(16,8))>comp$
            let stringa$=cvs(stringa$,32)
        endif
        if AND(valore$,bin(32,8))>comp$
            let stringa$=cvs(stringa$,4)
        endif
        if AND(valore$,bin(64,8))>comp$
            if len(stringa$)=0 then
                valore=valore-64
            fi
            for x=1 to len(stringa$)
            if stringa$(x,1)="[" then
                let stringa$(x,1)="("
            fi
            if stringa$(x,1)="]" then
                let stringa$(x,1)=")"
            fi
            next x    
        endif
        if AND(valore$,bin(128,8))>comp$
            let stringa$=cvs(stringa$,2)    
        endif
        if AND(valore$,bin(256,8))>comp$    
        endif
        if AND(valore$,bin(512,8))>comp$
            let stringa$=swap(stringa$,$02$)         
        endif
        if AND(valore$,bin(1024,8))>comp$
            if len(stringa$)=0 then
                valore=valore-1024
            fi
            let temp$=$$
            for x=1 to len(stringa$)
            if pos(stringa$(x,1)=" abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")<>0 then
                let temp$=temp$+stringa$(x,1)
            fi
            next x
            let stringa$=temp$
            valore=valore-1024
        endif
        if AND(valore$,bin(2048,8))>comp$
            let stringa$=tbl(stringa$,$7F$)     
        endif
        if AND(valore$,bin(4096,8))>comp$
            let stringa$=cvs(stringa$,8)            
        endif
        if AND(valore$,bin(8192,8))>comp$
            let stringa$=swap(stringa$,$08$)            
        endif





                CVTJ_exit:
        methodret stringa$

        CVTJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber NMV(BBjString value$)

        seterr NMVJ_err

        let x=num(value$,err=NOT_NUM)
        methodret 1

        NOT_NUM:
        methodret 0

        NMVJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString ALLBBJ(BBjString value$, BBjString character$)

        seterr ALLJ_err

        dim temp$(len(value$),character$)
        if value$="" then
            let temp$="* * * String that should not match with anything, hopefully... :) * * *"
        fi
        methodret temp$

        ALLJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString TSK(BBjNumber channel)

        seterr TSKJ_err

        if channel=0 
        let devices$=""
        dim temp$:"type:u(1),opens:u(1),alias:c(2*=0),device:c(10*=0),phys:c(10*=0),modes:c(80*=0)"
        dim tmpDevice$(6)
          while x<100
              let temp$=tsk(x,err=TSKJ_exit)
              alias$=temp.alias$
              rem allow aliases longer than 2 while keeping TBD compatibility  
              if len(alias$)>2 then 
                alias$=alias$(len(alias$)-1,2) 
              endif 
              tmpDevice$(1)=alias$+str(temp.opens)+temp.alias$ 
              let devices$=devices$+tmpDevice$
              let x=x+1
          wend
          methodret devices$
        endif 

        declare BBjSessionInfo sInfo! 
        declare BBjVector vec! 

            vec! = bbjapi().getSessionInfos() 

            for i=0 to vec!.size()-1 
            sInfo! = cast(BBjSessionInfo,vec!.getItem(i))

                        alias$=sInfo!.getTerminalID()
            if len(alias$)>2 then 
                alias$=alias$(len(alias$)-1,2) 
            endif 

                        if channel=2 and sInfo!.isBackground() then 
                let devices$=$00000000$+alias$
            endif 

                        if channel=3 and !sInfo!.isBackground() then 
                let devices$=devices$+alias$+"  "
            endif 

                    next i          

                goto TSKJ_exit

        TSKJ_exit:
        methodret devices$

        TSKJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString FID(BBjNumber channel)

        seterr FIDJ_err
        let temp$=fid(channel)
        if len(temp$)=2 or len(temp$)=3 then
            let fid_tbd$=temp$
	    if len(temp$)=3 and pos(temp$(1,1)="PT")>0 then fid_tbd$=fid_tbd$(2)
            goto FIDJ_exit  
        fi

        dim fid_tbd$(20)
        let fid_tbd$(4,6)=temp$(pos("/"=temp$,-1)+1)
        rem added for infodev 
        rem returns TB filetype 
        rem vkeyed returns msort 
        switch 1
           case temp$(1,1)=$0D$;fid_tbd$(10,1)=$06$;break 
           case default;fid_tbd$(10,1)=temp$(1,1);break
        swend

        let rec_num=dec(temp$(3,4))
        let fid_tbd$(12,3)=bin(rec_num)
        let key_size=dec(temp$(2,1))
        if rec_num<32768 then
            let fid_tbd$(11,1)=bin(key_size+4)
        else
            let fid_tbd$(11,1)=bin(key_size+6)
        fi
        let fid_tbd$(15,2)=temp$(7,2)

        rem disk number         
        filepath$=temp$(9)
        numdsk=#NUMDSK(filepath$)

        rem changed to cut filenames longer than 6 in two to mimic TB FID
        if numdsk=-1 then 
          filepath$=PAD(filepath$,MAX(6,len(filepath$))," ")
          fid_tbd$(4,6)=filepath$
          fid_tbd$(20,1)=chr(0)  
          fid_tbd$=fid_tbd$+str(filepath$(7),err=*next)
        else 
          fid_tbd$(20,1)=chr(numdsk)
          filename$=filepath$(pos("/"=filepath$,-1,1)+1)
          filename$=PAD(filename$,MAX(6,len(filename$))," ")
          fid_tbd$(4,6)=filename$
          fid_tbd$=fid_tbd$+str(filename$(7),err=*next)         
        endif 
        FIDJ_exit:
        methodret fid_tbd$

        FIDJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber FILE(BBjString fid_tbd$)

        seterr FILEJ_err

        file fid_tbd$(23)
        methodret 0

        FILEJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber DIR(BBjString file_name$, BBjNumber key_size, BBjNumber num_rec, BBjNumber rec_size, BBjNumber disk_num, BBjNumber sec_num)

        seterr DIRJ_err

        mkeyed stbl("!ARCHIVI")+file_name$,key_size,0,rec_size
        methodret 0

        DIRJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber SOR(BBjString file_name$, BBjNumber key_size, BBjNumber num_rec, BBjNumber disk_num, BBjNumber sec_num)

        seterr SORJ_err

        mkeyed stbl("!ARCHIVI")+file_name$,key_size,0,0
        methodret 0

        SORJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber TEX(BBjString file_name$, BBjNumber disk_num, BBjNumber sec_num)

        seterr TEXJ_err

        if disk_num = 2 then
            string stbl("!ARCHIVI")+file_name$
        else
            string stbl("!ESPORTAZIONI")+file_name$
        fi

        methodret 0

        TEXJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString WGL(BBjNumber dummy)

        seterr WGLJ_err

        print (0) 'EE'+'CI'+'WINDOW'("LIST"),
        read record (0,siz=1) count$
        read record (0,siz=asc(count$)) list$
        print (0) 'BE',
        methodret list$

        WGLJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber WDA(BBjNumber dummy)

        seterr WDAJ_err

        list$=TB.WGL(0)
        for x=1 to len(list$)
            let win=dec(list$(x,1))
            if win then
                print 'DROP'(win)
            fi
        next x
        methodret 0

        WDAJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString E47(BBjString stringa$, BBjNumber offs, BBjNumber length)

        methodret str(stringa$(offs,length),err=*next)
        methodret ""

    methodend

    method public static BBjString E47(BBjString stringa$, BBjNumber offs)

        methodret str(stringa$(offs),err=*next)
        methodret ""

    methodend

    method public static BBjString GPH(BBjString stringa$, BBjString caratteri$)

        seterr GPHJ_err
        let stringa$=stringa$+$00$, car1$="", car2$="37584629:01", graph$=""
        for x=1 to len(caratteri$) step 3
            let car1$=car1$+chr(num(caratteri$(x,3)))
        next x
        while stringa$<>$00$
            let p=pos(stringa$(1,1)=car1$)
            if p<>0 then
                let graph$=graph$+'GS'+fill(pos(car1$(p,1)<>stringa$(2)),car2$(p,1))+'GE'
                let stringa$=stringa$(pos(car1$(p,1)<>stringa$))
            else
                let graph$=graph$+stringa$(1,1)
                let stringa$=stringa$(2)
            fi
        wend
        methodret graph$

        GPHJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

        methodend

    method public static BBjNumber WGN(BBjNumber dummy)

        seterr WGNJ_err

        list$=TB.WGL(0)
        methodret dec(list$(1,1))

        WGNJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber WDL(BBjString lista1$)

        seterr WDLJ_err

        lista2$=TB.WGL(0)
        for x=1 to len(lista2$)
            if pos(lista2$(x,1)=lista1$)=0 then
                let win=dec(lista2$(x,1))
                if win then
                    print @(0,0),'DROP'(win),
                fi
            fi
        next x
        methodret 0

        WDLJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

        rem /* 
    rem *   LIKE
    rem */
    method public static Boolean LIKE(BBjString a!,BBjString b!) 
        rem /* map TBD regexpr to java 
        rem map ? to . 
        rem map [?] to \?
        rem map [*] to \*
        rem map [[] to \[
        rem replace * par .*
        rem */ 
        b! = b!.replaceAll("\\","\\\\")
        b! = b!.replaceAll("\[\*\]","\\*") 
        b! = b!.replaceAll("\[\?\]","\\?") 
        b! = b!.replaceAll("(?<!\\)\?",".")  
        b! = b!.replaceAll("\[\[\]","\\[") 
        b! = b!.replaceAll("(?<!\\)\*","\.\*") 
        b! = b!.replaceAll("\(","\\\(")
        b! = b!.replaceAll("\)","\\\)")
        b! = b!.replaceAll("\{","\\{") 
        b! = b!.replaceAll("\}","\\}") 
        methodret a!.matches(b!,err=*next)
        methodret BBjAPI().FALSE
    methodend 


        rem /* 
    rem * replaces the tb unt(filename$) function that retrieve the first channel on which the file was opened
    rem * @param the name of the file to retrieve the channel 
    rem * @return the first channel on which the file was opened 
    rem */ 
    method public static BBjNumber TBUNT(BBjString unt$) 
      LET UNT0$=CHN,UNT0=1
      UNT_LOOP:
      IF UNT0>LEN(UNT0$) THEN methodret 0
      LET UNT1=DEC(UNT0$(UNT0,2)),UNT1$=FID(UNT1)
      IF POS(UNT1$(1,1)=$000102030405060786$) AND UNT1$(9)=UNT$ THEN methodret UNT1
      LET UNT0=UNT0+2
      GOTO UNT_LOOP
    methodend 

        rem /*
    rem * For positive numbers, this numeric function returns the truncated integer portion of the number (the 
    rem *same as the INT function). For negative numbers, this function returns the integer portion of the number 
    rem *unconditionally rounded to the next smaller negative integer if the original negative number contained 
    rem *any fractional portion.
    rem reflect TB's FIX
    rem */ 
    method public static BBjNumber FIX(BBjNumber N)
        IF N<0 AND N<>INT(N) THEN LET N=INT(N-1) ELSE LET N=INT(N)
        methodret N
    methodend 

        rem /*
    rem * INFODEV, Christophe RICHARD
    rem * This function is design to simulate the Tbred logical disk
    rem * in the config.bbx we add some global vars like
    rem * SET !DSK_D0=/infodev/tmp/UTILBBJ/
    rem * SET !DSK_D4=/infodev/tmp/IFAGIV4/
    rem * ...
    rem * TB.REPDSK(DSK) is used to get the string directory from a number of disq
    rem * This string is used to create files 
    rem */
    method public static BBjString REPDSK(BBjNumber numdsk)
        seterr REPDSKError
        methodret STBL("!DSK_D"+str(numdsk))
        REPDSKError: 
        throw "Invalid disk",12
    methodend

    rem /*
    rem * INFODEV, Christophe RICHARD
    rem * This function is design to simulate the Tbred logical disk
    rem * in the config.bbx we add some global vars like
    rem * SET !DSK_D0=/infodev/tmp/UTILBBJ/
    rem * SET !DSK_D4=/infodev/tmp/IFAGIV4/
    rem * ...
    rem * TB.REPDSK(DSK) is used to get the string directory from a number of disq
    rem * This string is used to create files 
    rem */
    method public static BBjNumber NUMDSK(BBjString filepath$)
        numdsk=-1
	if len(filepath$)>0 AND filepath$(LEN(filepath$),1)<>"/" THEN
	filepath$=filepath$+"/"
	fi
        FOR dsk=0 to 9
            repdsk$=STBL("!DSK_D"+str(dsk),err=labnext)
            if pad(filepath$,len(repdsk$))=repdsk$ then numdsk=dsk; break
            labnext:
        NEXT dsk
        methodret numdsk
    methodend

    rem /*
    rem * addsort  
    rem */
    method public static void ADDSORT(BBjString file$, BBjString sortname$,BBjString keyChain$)
         seterr m_error
         rem #ToDo: add throw exception 17 if key already exists
            declare BBjFileInfo info! 

            ch=unt;open(ch)file$ 
            info! = #fileSystem!.getFileInfo(ch) 

            declare BBjKeyInfo keyInfo! 
            keyInfo! = #getKeyInfo(keyChain$) 
            info!.lock()
            info!.addKey(sortname$,keyInfo!)
            info!.unlock()
            close(ch)
        methodret
        m_error: 
         System.out.println("Error adding sort"+str(err)+str(tcb(5)))
    methodend 

            rem /*
    rem * addsort  
    rem */
    method public static void REMSORT(BBjString file$, BBjString sortname$)
         seterr remsort_error
            declare BBjFileInfo info! 

                        ch=unt;open(ch)file$ 
            info! = #fileSystem!.getFileInfo(ch) 

                        declare BBjKeyInfo keyInfo! 
            info!.lock()
            info!.dropKey(sortname$)
            info!.unlock()
            close(ch)
        methodret
        remsort_error: 
         System.out.println("Error removing sort"+str(err)+str(tcb(5)))
    methodend 

    method public static BBjKeyInfo getKeyInfo(BBjString keyDefinition$) 
        declare BBjVector keySegments! 
        keySegments! = bbjapi().makeVector()
        if len(keyDefinition$)=0 then methodret null() 
        if keyDefinition$(1,1) <>"[" then keyDefinition$=keyDefinition$(pos("["=keyDefinition$)) endif 
        declare String segments!
        dim segments![0]

        if pos("+"=keyDefinition$)>0 then 
            segments! = keyDefinition$
            segments![]=segments!.split("\+") 
        else 
            segments![0]=keyDefinition$
        endif 

                i=0
        while 1 
            tmpKeySegment$ = str(segments![i],err=*break)
            m_field=num(tmpKeySegment$(pos("["=tmpKeySegment$)+1,pos(":"=tmpKeySegment$)-((pos("["=tmpKeySegment$)+1))) )
            m_pos=num(tmpKeySegment$(pos(":"=tmpKeySegment$,1,1)+1,pos(":"=tmpKeySegment$,1,2)-((pos(":"=tmpKeySegment$,1,1)+1))) )
            if pos(":"=tmpKeySegment$,1,0)=2 then 
                m_len=num(tmpKeySegment$(pos(":"=tmpKeySegment$,1,2)+1,pos("]"=tmpKeySegment$)-((pos(":"=tmpKeySegment$,1,2)+1))) )
                m_desc!=bbjapi().FALSE
            else
                m_len=num( tmpKeySegment$(pos(":"=tmpKeySegment$,1,2)+1,pos(":"=tmpKeySegment$,1,3)-((pos(":"=tmpKeySegment$,1,2)+2))) )
                if pos("D"=tmpKeySegment$)>0 then 
                    m_desc!=bbjapi().TRUE
                else 
                    m_desc!=bbjapi().FALSE
                endif
            endif 
            rem m_pos add 1 at keySegmentCreation
            keySegment! = #fileSystem!.makeKeySegment(m_field,m_pos-1,m_len,m_desc!,BBjAPI().FALSE)
            keySegments!.add(keySegment!)            
            i=i+1
        wend 
            isUnique! = bbjapi().FALSE
            if pos("U"=tmpKeySegment$) then isUnique!=bbjapi().TRUE            
            keyInfo! = #fileSystem!.makeKeyInfo(keySegments!,isUnique!)
        methodret keyInfo!
        methodend 
    rem A D  ]:"U"
    rem /*
    rem * remsort 
    rem */ 
    method public static void REMSORT(BBjString fileName$,BBjString sortName$)
        seterr RemSortError
        declare BBjFileInfo info! 
        ch=unt 
        open(ch)fileName$ 
        info! = bbjapi().getFileSystem().getFileInfo(ch) 
        info!.lock() 
        info!.dropKey(sortName$)
        info!.unlock()
        close(ch)
        methodret 
        RemSortError: 
            System.out.println("error removing index:"+fileName$+ " "+sortName$)
    methodend 

    rem change keyname or set keyname for first key 
    method public static void setKeyName(BBjString fileName$,BBjString oldKeyName$,BBjString newKeyName$)
        ch=unt 
        open(ch)filename$
        declare BBjFileInfo info! 
        info! = bbjapi().getFileSystem().getFileInfo(ch)
        info!.lock() 
        info!.setKeyName(oldKeyName$,newKeyName$,err=*next);info!.unlock();close(ch); methodret 
        info!.setKeyName(0,newKeyName$) 
        info!.unlock()
        close(ch)         
    methodend     

         method public static void setKeyName(BBjString fileName$,BBjNumber keyIndex,BBjString newKeyName$)
        ch=unt 
        open(ch)filename$
        declare BBjFileInfo info! 
        info! = bbjapi().getFileSystem().getFileInfo(ch) 
        info!.lock()
        info!.setKeyName(keyIndex,newKeyName$,err=*next) 
        info!.unlock()
        close(ch)
REM         info!.setKeyName(0,newKeyName$) 
    methodend     


    rem /* 
    rem *
    rem * allbbj 
    rem * checks if string is composed of char
    rem *
    rem */ 
    method public static boolean ALLBBj(BBjString input$,BBjString compareString$)
        seterr not_equal
        if input$="" and compareString$>"" then methodret bbjapi().FALSE endif 
        if input$=FILL(len(input$),compareString$(1,1)) then methodret bbjapi().TRUE endif 
        not_equal: 
        methodret bbjapi().FALSE
    methodend  


    method public static BBjString DSD(BBjString dev$) 
	SETERR ERR_DSD
	if #LIKE(dev$,"D?") then
        dim fid$(86)
		fid$(1,2)=dev$
		fid$(6,1)=$00$
		fid$(23)=STBL("!DSK_"+dev$)
	else
        	dim fid$(72)
        	fid$(1)=fid(0) 
        	if dev$=fid(0) then 
            	dev$=fid$(1,2) 
        	endif 
        	fid$(11,8)=stbl("!ID_TERM",err=*next)
	endif
        methodret fid$
	ERR_DSD:
	methodret ""
    methodend 

    method public static BBjString XFD(BBjNumber channel,BBjNumber func)
        dim xfd$(100) 
        declare BBjFileInfo info! 
        info! = bbjapi().getFileSystem().getFileInfo(channel,err=*next)

        bbjFid$=fid(channel)
        fileName$=str(bbjFid$(9),err=*next)

        declare LinuxFileInfo lFileInfo!
        lFileInfo! = new LinuxFileInfo(fileName$,err=*next) 


        switch func 
        case 0 
            dim xfd$(85)
            xfd$=fill(85,$00$)
            xfd$(1,1)=$01$
            xfd$(3,8)=bin(lFileInfo!.getInode(),8)
            xfd$(38,4)=bin(lFileInfo!.getFileSize(),4)
            xfd$(54,6)=bin(lFileInfo!.getLastChanged(),6)
            xfd$(60,6)=bin(lFileInfo!.getLastAccess(),6)
            xfd$(66,6)=bin(lFileInfo!.getLastModified(),6)
            xfd$=xfd$+fileName$
            rem todo: handle large files
            break 
        case 1 
            dim xfd$(39)
            xfd$=bin(0,40)
            fileName$=fid(channel)
            device!=null()
            device!=#deviceList!.get(fileName$)
            type$=$00$
            dType$=device!.getFieldAsString("TYPE")
            switch 1 
            case dType$=$00$; type$=$07$;break 
            case dType$=$01$; type$=$04$;break 
            case dType$=$02$; type$=$08$;break 
            swend 
            if device!=null() then 
                if lFileInfo!.getFileType()="d" then 
                    type$=$01$
                endif 
            endif 

            xfd$(1,1)=type$

            alias$=fileName$
            if len(alias$)>2 then alias$=alias$(len(alias$)-1,2) endif       
            xfd$(2,2)=alias$

              if type$=$04$ then 
              rem todo: 4-5 Current cursor row number, 0-based, binary; terminals and printers only
              rem todo: 6-7 Current cursor column number, 0-based, binary; terminals and printers only
              rem todo: 8-9 Maximum screen/line width, binary; terminals and printers only
              rem todo: 10-11 Maximum screen/page height, binary; terminals and printers only
              rem todo: 12 Spooler type, binary; printers only:
              rem todo: 13 ockout flag, binary; printers only:

                            rem windows only 14-15   Timeout value in seconds, binary; printers only
              rem windows only 16-17  Usable screen width, binary; Windows CE only  
              rem windows only 18-19  Usable screen height, binary; Windows CE only
              cmd$=device!.getFieldAsString("PHYS")
              cmd$=cmd$(pos("LP"=cvs(cmd$,4)))
              
              xfd$=xfd$+cvs(cmd$,16)

              endif 

                        rem 20 unsuported 
            rem 21 unsuported 
            rem 22-39 unused 

                        rem todo: Non-printers: Host name of device

                              break 
        case 2 
            break 
        case 3 
          dim xfd$(44)
          xfd$=fill(44,$00$)

                    xfd$(1,1)=$01$

                    bbjFileType$=bin(info!.getFileType())     
          switch 1
          case bbjfiletype$=$84$;xfd$(2,1)=$04$;break
          case bbjfiletype$>=$08$;xfd$(2,1)=$06$;break
          rem $00$ to $04$ default 
          case default; xfd$(2,1)=bbjFileType$;break
          swend 

          declare BBjVector keyVector! 
          keyVector! = info!.getKeyInfo(err=*next)           
          numKeys=0
          numKeys=keyVector!.size(err=*next) 
          xfd$(3,1)=bin(numKeys)

          currentKey=0
          currentKey=info!.getCurrentKeyNumber(err=*next)
          xfd$(4,1)=bin(currentKey)

                    xfd$(5,1)="N"

                    xfd$(6,1)="N"
          if bbjFileType$=$00$ then xfd$(6,1)="Y" endif 

                    xfd$(7,1)="Y"

          rem todo: 13-14 Index node size for MSORT and TISAM files; unsigned binary
          rem 15-16 not used The minimum record size (COBOL files only)
          rem todo: 17 Duplicate number width for MSORT and TISAM files
          rem todo: 18-19 Current commit counter ?
          rem todo: 20-21 Channel's commit count, non-zero if overridden by the CTC=option, otherwise zero
          rem todo: 22-45 unused 

          declare BBjVector keys! 
          keys! = info!.getKeyInfo() 

                    for numKey=0 to keys!.size()-1  

                      dim keyInfo$(39) 
            keyInfo$=fill(39,$00$)
            declare BBjKeyInfo keyInfo!          

                keyInfo! = info!.getKeyInfo(numKey)
            keyLen = #getKeyLen(keyInfo!.getKeySegments())        

              keySegments! = keyInfo!.getKeySegments()
            numSegments=keySegments!.size()   


            rem todo: check 45,1
            keyInfo$(1,1)=bin(keyLen)
            keyInfo$(2,1)=bin(numSegments)
            keyInfo$(3,1)=$00$ 
            keyName$=str(numKey)
            if info!.getKeyName(0,err=*next)<>null() then keyName$=info!.getKeyName(numKey) endif 
            keyInfo$(4,20)=keyName$+fill(20-len(keyName$),$00$)
            rem todo: byte 24 = Key may be modified
            keyInfo$(24,1)="Y"
            keyInfo$(25,1)="N"
            rem if keyInfo!.isUnique() then keyInfo$(25,1)="Y" else keyInfo$(25,1)="N" endif 
            rem bytes 27,5 = Unused
            rem todo: byte 32 = Field number (0 = no field number specified), unsigned binary get fieldnumber
            rem 33,6 not used



            for numSegement=0 to numSegments-1            
              keySegment! = keySegments!.get(numSegement)
              dim segmentInfo$(8)
              segmentInfo$=fill(8,$00$)
              segmentInfo$(1,1)=bin(keySegment!.getField())
              segmentInfo$(2,2)=bin(keySegment!.getOffset()+1,2)
              segmentInfo$(4,1)=bin(keySegment!.getLength())    
              if keySegment!.isDescending() then segmentInfo$(5,1)="D" else segmentInfo$(5,1)="A" endif 

                            keyInfo$=keyInfo$+segmentInfo$
            next numSegement
            xfd$=xfd$+keyInfo$
          next numKey
                      break 
        case 5 
            xfd$=TB.FID(channel) 
            xfd$=xfd$+$00$
            xfd$=xfd$+TB.XFD(channel,3)
            break 
        case 6 
          bbjfiletype$=bbjFid$(1,1) 
          xfd$=fill(8,$00$) 
          switch 1
          case bbjfiletype$=$05$;xfd$(1,1)=$0A$;break
          case bbjfiletype$>=$20$;xfd$(1,1)=$06$;break
          rem $00$ to $04$ default 
          case default; xfd$(1,1)=bbjFileType$
          swend 
          keySize=0
          keySize=info!.getKeySize(err=*next)
          xfd$(2,1)=bin(keySize) 
          xfd$(3,3)=bin(info!.getCurrentRecords(),5)
          xfd$(7,2)=bin(info!.getRecordSize(),2)
          sep$=java.io.File.separator
          
          if pos(sep$=fileName$)>0 then 
            fileName$=fileName$(pos(sep$=fileName$,-1,1)+1)
          endif 
          xfd$=xfd$+fileName$        
            break 
        case 10 
            xfd$=bin(info!.getCurrentRecords(),5)
            break 
        swend 

        methodret xfd$
    methodend 

    method public static BBjNumber getKeyLen(BBjVector keySegments!) 
        keyLen=0
        for i=0 to keySegments!.size()-1
            keyLen=keyLen+cast(BBjKeySegment,keySegments!.get(i)).getLength() 
        next i
        methodret keyLen
    methodend 

    method public static void killSession(BBjString ses$) 
        seterr killError 
        if ses$="" then methodret 
        declare BBjVector sessions!  

                sessions! = bbjapi().getSessionInfos()

                for i=0 to sessions!.size()-1 
            if pos(ses$=cast(BBjSessionInfo, sessions!.get(i)).getIPAddress())>0 then 
                bbjapi().killSession(cast(BBjSessionInfo, sessions!.get(i)),"admin","admin123")
                methodret
            endif 
        next i
        methodret
        killError: 
        System.out.println("Error killing session"+str(err)+str(tcb(5)))
    methodend 


    rem closeAll 
    method public static void closeAll() 
        declare InetAddress addr! 
        addr! = InetAddress.getByName("127.0.0.1") 

        declare BBjAdminBase AdminBase! 
        AdminBase! = BBjAdminFactory.getBBjAdmin(addr!,2002,BBjAPI().FALSE,100,"admin","admin123")

        declare java.util.List openFiles! 
        openFiles! = AdminBase!.getOpenFiles()

        declare Iterator it!
        it!=openFiles!.iterator()
        mid=dec(info(3,0))
        declare BBjAdminOpenFile tmpFile! 
        if it!<>null() then 
            while it!.hasNext()
                tmpFile! = cast(BBjAdminOpenFile, it!.next()) 
                idString$ = tmpFile!.getProperties().get("id")
                fileOpenId=num(idString$(pos(":"=idString$)+1),err=*continue)
                if fileOpenId=mid then 
                    tmpFile!.forceClose()
                endif 
            wend 
        endif 

       methodend 

      method public static BBjString FST(BBjString file$, BBjNumber option) 
        seterr FSTError
        ch=unt
        open(ch)file$ 
        mfid$=fid(ch)
        close(ch)

                dim fst$(118)
        if option=1 then 
          rem 1-2
          fst$(1)=$0020$
          rem 3-4 
          fst$(3,2)=$0000$
          rem 5-6 file type 
          bbjFileType$=mfid$(1,1) 
          fst$(5,1)=$00$      
          switch 1
          case bbjfiletype$=$05$;fst$(6,1)=$0A$;break
          case bbjfiletype$>=$20$;fst$(6,1)=$06$;break
          rem $00$ to $04$ default 
          case default; fst$(6,1)=bbjFileType$
          swend 
        endif 

                rem *nix OS 
        ch=unt 
        open(ch)"| /usr/bin/stat "+file$ 
        while 1 
            read(ch,end=*break)tmpFileInfo$ 

                        if pos("File:"=tmpFileInfo$,1,1)>0 and pos("->"=tmpFileInfo$,1,1)>0 then 
                filePath$=tmpFileInfo$(pos("`"=tmpFileInfo$,1,2)+1,pos("'"=tmpFileInfo$,1,2)-(pos("`"=tmpFileInfo$,1,2)+1))
                continue
            endif 

                        rem device infomation 
           if tmpFileInfo$(1,6)="Device" then 
             device$=tmpFileInfo$(pos(" "=tmpFileInfo$,1,1)+1,pos("/"=tmpFileInfo$,1,1)-pos(" "=tmpFileInfo$,1,1)-2)
             fst$(11,4)=ath(fill(8-len(device$),"0")+device$)

             inode$=tmpFileInfo$(pos("Inode: "=tmpFileInfo$,1,1)+7,pos("Links"=tmpFileInfo$,1,1)-1-(pos("Inode: "=tmpFileInfo$,1,1)+7))
             fst$(15,4)=bin(num(inode$))

             rem TODO: 19-20 File protection bits             
             numLinks$=tmpFileInfo$(pos("Links: "=tmpFileInfo$)+len("Links: "))
             fst$(23,2)=bin(num(numLinks$))
             continue
            endif 

                        if pos("Uid:"=tmpFileInfo$)>0 then 
                fileType$=tmpFileInfo$(pos("/"=tmpFileInfo$,1,1)+1,1)
                switch 1 
                case fileType$="d";fst$(21,2)=$000A$;break 
                rem TODO: System File
                case fileType$="b";fst$(21,2)=$0040$;break
                case fileType$="c";fst$(21,2)=$0041$;break
                case fileType$="p";fst$(21,2)=$0042$;break
                rem UNIX Network Special
                case fileType$="s";fst$(21,2)=$0044$;break  
                case fileType$="l";fst$(21,2)=$0045$;break   
                case default;fst$(21,2)=$004F$;break 
                swend

                                uid$=tmpFileInfo$(pos("("=tmpFileInfo$,1,2)+1,pos("/"=tmpFileInfo$,1,2)-(pos("("=tmpFileInfo$,1,2)+1))
                fst$(25,2)=bin(num(uid$)) 

                                gid$=tmpFileInfo$(pos("("=tmpFileInfo$,1,3)+1,pos("/"=tmpFileInfo$,1,3)-(pos("("=tmpFileInfo$,1,3)+1))
                fst$(27,2)=bin(num(gid$)) 

                                rem todo: Device ID. This entry is valid only for Block and character special devices
                fst$(29,4)=$00000000$
                continue 
            endif 
            if pos("Size:"=tmpFileInfo$,1,1)>0 and pos("Uid"=tmpFilePos$,1,1)=0 then 
                fileSize$=tmpFileInfo$(pos("Size:"=tmpFileInfo$,1,1)+6,pos("Blocks:"=tmpFileInfo$,1,1)-(pos("Size:"=tmpFileInfo$,1,1)+6))
                fst$(33,4)=bin(num(cvs(fileSize$,16)))
            endif 

                        if pos("Change:"=tmpFileInfo$,1,1)>0 then 
                changed$=tmpFileInfo$(9,20) 
                fst$(37,6)=bin(round(TB.DTN(changed$,"YYYY-MM-DD HH:MI:SS"),0))
                continue 
            endif 

                        if pos("Access:"=tmpFileInfo$,1,1)>0 and pos("Uid:"=tmpFileInfo$,1,1)=0 then 
                changed$=tmpFileInfo$(9,20) 
                fst$(43,6)=bin(round(TB.DTN(changed$,"YYYY-MM-DD HH:MI:SS"),0))
                continue 
            endif 

                    wend 
        close(ch) 

                methodret fst$+filePath$
        FSTError:
        System.out.println("Error FSTs"+str(err)+" "+str(tcb(5)))
        methodret ""
      methodend 

      method public BBjString DSD(BBjString in$) 
        seterr DSDError
        dim dsd$(150) 

        config$=BBjApi().getConfig().getConfigFileName()
        ch=unt 
        open(ch)"|/bin/cat "+config$+" | grep "+in$
        read(ch,end=*next)dAlias$
        if pos(" "+in$+" "=dAlias$,1,1)=0 then dAlias$="" endif 
        close(ch)


        dsd$(1,3)=in$;rem hta(fid(0))

                switch 1 
        case in$(1,1)="T"
            dsd$(4,1)="T"
            dsd$(5,1)=$00$
            dsd$(6,1)=$00$
            dsd$(11,8) = STBL("!ID_TERM")
            break 
        case in$(1,1)="P" 
            dsd$(4,1)="P"
            dsd$(5,1)=$09$
            if pos("lp -d"=dAlias$,1,1)>0 then dsd$(6,1)=$01$ endif 
            if pos("/dev/tty"=dAlias$,1,1)>0 then dsd$(6,1)=$02$ endif 
            break
        case in$(1,1)="D"
            dsd$(23,64) = STBL("!DSK_"+cvs(in$,3))    
            break
        case default
            dsd$(5,1)=$00$
            dsd$(6,1)=$00$
            break 
        swend




        rem dsd 7,47 - DOS 
        methodret dsd$
        DSDError:
        System.out.println("Error DSD"+str(err)+" "+str(tcb(5)))
        methodret ""
      methodend 


      method public static LinkedHashMap getDeviceList()
        if #deviceList!=null() then 
          #deviceList!=new LinkedHashMap() 
          declare BBjTemplatedString temp! 

          for i=0 to 99 
              temp! = bbjapi().makeTemplatedString("type:u(1),opens:u(1),alias:c(2*=0),device:c(10*=0),phys:c(10*=0),modes:c(80*=0)") 
              temp!.setString(TSK(i,err=*break))
              alias$=temp!.getFieldAsString("ALIAS")
              #deviceList!.put(alias$,temp!) 
          next i 
        endif 
        methodret #deviceList! 
      methodend 

      method public static BBjTemplatedString getDevice(BBjString device$) 
        seterr getDeviceError
        methodret cast(BBjTemplatedString,#deviceList!.get(device$))
        getDeviceError: 
         throw errmes(-1)+" in class TB at line "+str(tcb(5)),err
      methodend 

      method public static BBjString PKY(BBjNumber channel) 
        seterr PKYError
            if key(channel)=keyf(channel) then goto PKYError endif 
            read (channel,dir=-1)
            pky$=keyp(channel,err=PKYErrorKey)
            read (channel) 
            methodret pky$
        PKYError: 
            throw errmes(-1)+" in class TB at line "+str(tcb(5)),2
        PKYErrorKey: 
            read (channel)
            throw errmes(-1)+" in class TB at line "+str(tcb(5)),2
      methodend 


    classend

        class public LinuxFileInfo 

        field private BBjString filePath$
        field private BBjString device$ 
        field private BBjNumber inode
        field private BBjNumber numLinks
        field private BBjString fileType$
        field private BBjNumber uid 
        field private BBjNumber gid 
        field private BBjNumber fileSize 
        field private BBjNumber lastChanged
        field private BBjNumber lastAccess
        field private BBjNumber lastModified

        method private LinuxFileInfo() 
        methodend 

        method public LinuxFileInfo(BBjString file$)
        seterr LinuxFileInfoError

                PRC=tcb(14)
        PRECISION 4

                rem *nix OS 
        ch=unt 
        open(ch)"| /usr/bin/stat "+file$ 
        while 1 
            read(ch,end=*break)tmpFileInfo$ 

            if pos("File:"=tmpFileInfo$,1,1)>0 and pos("->"=tmpFileInfo$,1,1)>0 then 
                #filePath$=tmpFileInfo$(pos("`"=tmpFileInfo$,1,2)+1,pos("'"=tmpFileInfo$,1,2)-(pos("`"=tmpFileInfo$,1,2)+1))
                continue
            endif 

           rem device infomation 
           if tmpFileInfo$(1,6)="Device" then 
             device$=tmpFileInfo$(pos(" "=tmpFileInfo$,1,1)+1,pos("/"=tmpFileInfo$,1,1)-pos(" "=tmpFileInfo$,1,1)-2)
             #device$=fill(8-len(device$),"0")+device$

             inode$=tmpFileInfo$(pos("Inode: "=tmpFileInfo$,1,1)+7,pos("Links"=tmpFileInfo$,1,1)-1-(pos("Inode: "=tmpFileInfo$,1,1)+7))
             #inode=num(inode$)

                          rem TODO: 19-20 File protection bits             
             numLinks$=tmpFileInfo$(pos("Links: "=tmpFileInfo$)+len("Links: "))
             #numLinks=num(numLinks$)
             continue
            endif 

            if pos("Uid:"=tmpFileInfo$)>0 then 
                #fileType$=tmpFileInfo$(pos("/"=tmpFileInfo$,1,1)+1,1)

                uid$=tmpFileInfo$(pos("("=tmpFileInfo$,1,2)+1,pos("/"=tmpFileInfo$,1,2)-(pos("("=tmpFileInfo$,1,2)+1))
                #uid=num(uid$)

                gid$=tmpFileInfo$(pos("("=tmpFileInfo$,1,3)+1,pos("/"=tmpFileInfo$,1,3)-(pos("("=tmpFileInfo$,1,3)+1))
                #gid=num(gid$)

                rem todo: Device ID. This entry is valid only for Block and character special devices
                continue 
            endif 
            if pos("Size:"=tmpFileInfo$,1,1)>0 and pos("Uid"=tmpFilePos$,1,1)=0 then 
                fileSize$=tmpFileInfo$(pos("Size:"=tmpFileInfo$,1,1)+6,pos("Blocks:"=tmpFileInfo$,1,1)-(pos("Size:"=tmpFileInfo$,1,1)+6))
                #fileSize=num(cvs(fileSize$,16))
            endif 

            if pos("Change:"=tmpFileInfo$,1,1)>0 then 
                changed$=tmpFileInfo$(9,19) 
                #lastChanged=round(TB.DTN(changed$,"YYYY-MM-DD HH:MI:SS")*1000,0)
                continue 
            endif 

                        if pos("Modify:"=tmpFileInfo$,1,1)>0 then 
                lastModified$=tmpFileInfo$(9,19) 
                #lastModified=round(TB.DTN(lastModified$,"YYYY-MM-DD HH:MI:SS")*1000,0)
                continue 
            endif 

            if pos("Access:"=tmpFileInfo$,1,1)>0 and pos("Uid:"=tmpFileInfo$,1,1)=0 then 
                changed$=tmpFileInfo$(9,19) 
                #lastAccess=round(TB.DTN(changed$,"YYYY-MM-DD HH:MI:SS")*1000,0)
                continue 
            endif 
        wend 
            PRECISION PRC
            methodret 
            LinuxFileInfoError:
            PRECISION PRC
            System.out.println("Error DSD"+str(err)+" "+str(tcb(5)))
        methodend 

        method public BBjString getFilePath() 
            methodret #filePath$
        methodend 

        method public BBjString getDevice() 
            methodret #device$ 
        methodend 

        method public BBjNumber getInode() 
            methodret #inode
        methodend 

        method public BBjNumber getNumLinks() 
            methodret #numLinks
        methodend 

        method public BBjString getFileType() 
            methodret #fileType$
        methodend 

        method public BBjNumber getUID() 
            methodret #uid
        methodend 

                 method public BBjNumber getGID() 
            methodret #gid
        methodend 

        method public BBjNumber getFileSize() 
            methodret #fileSize
        methodend 

        method public BBjNumber getLastChanged() 
            methodret #lastChanged
        methodend 

        method public BBjNumber getLastAccess() 
            methodret #lastAccess
        methodend 

        method public BBjNumber getLastModified() 
            methodret #lastModified
        methodend 

         classend 
