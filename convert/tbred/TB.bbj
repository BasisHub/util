class public TB


    field public static BBjFileSystem fileSystem! = bbjapi().getFileSystem() 

    method public static BBjNumber UNT0(BBjString fichier$)
	canal=0
	SETERR UNT_END
	C=UNT; OPEN (C,ERR=UNT_END) fichier$
	fichier$=CVS(FID(C)(9),2)
	CLOSE(C)
	lcan$=CHN
	i=1
	WHILE (i < LEN(LCAN$) )
		canalt=DEC($00$+lcan$(i,2))
		if canalt > 0 then
			fichier0$ = cvs(FID(canalt)(9),2)
			if (fichier$ = fichier0$) then
				canal=canalt
				break
			fi
		fi
		i=i+2
	WEND
	UNT_END:
	methodret canal
    methodend

    method public static BBjNumber DTN(BBjString dateval$, BBjString datemask$)
        seterr DTNJ_err
        prc=tcb(14)
        PRECISION 8
REM         if num(dateval$)<=0 or len(dateval$)<>len(datemask$) then
REM             goto DTNJ_err
REM         fi
        let dt$=$$, mk$=$$, datemask$=cvs(datemask$,4)

                let x=pos("YYYY"=datemask$)
        if x<>0 then
            let dt$=dt$+dateval$(x,4), mk$=mk$+"%Yl", datemask$(x,4)="xxxx"
        fi

        let x=pos("YY"=datemask$)
        if x<>0 then
            if num(dateval$(x,2))>50 then
                let dt$=dt$+"19"+dateval$(x,2)
            else
                let dt$=dt$+"20"+dateval$(x,2)
            fi
            let mk$=mk$+"%Yl", datemask$(x,2)="xx"
        fi

        let x=pos("MM"=datemask$)
        if x<>0 then
            let dt$=dt$+dateval$(x,2), mk$=mk$+"%Mz", datemask$(x,2)="xx"
        else
            let dt$=dt$+"01", mk$=mk$+"%Mz"
        fi

        let x=pos("DD"=datemask$)
        if x<>0 then
            let dt$=dt$+dateval$(x,2), mk$=mk$+"%Dz", datemask$(x,2)="xx"
        else
            let dt$=dt$+"01", mk$=mk$+"%Dz"
        fi
        
        datedec=0
        
        let x=pos("HH"=datemask$)
        if x<>0 then
            let datedec=num(dateval$(x,2))/24
        fi
        
        let x=pos("MI"=datemask$)
        if x<>0 then
            let datedec=datedec+num(dateval$(x,2))/24/60
        fi
        
        let x=pos("SS"=datemask$)
        if x<>0 then
            let datedec=datedec+num(dateval$(x,2))/24/60/60
        fi
        
        PRECISION prc
        dtn = jul(dt$,mk$)-1721423
        methodret dtn+datedec
        
        DTNJ_err:
        PRECISION prc
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString NTD(BBjNumber dateval, BBjString datemask$)
    
        seterr NTDJ_err
              
        if dateval=0 then 
            dateval=JUL(0,0,0)-1721423
            datedec=TIM
        else    
            datedec=dateval
            dateval=round(dateval,0)
            datedec=datedec-dateval
            datedec=datedec*24   
        endif
   
        let x=pos("YYYY"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Yl"+datemask$(X+4)
        fi

        let x=pos("YY"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Yz"+datemask$(X+2)
        fi

        let x=pos("MM"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Mz"+datemask$(X+2)
        fi

	let x=pos("DDD"=datemask$)
	if x<>0 then
		annee$=TB.NTD(dateval,"YYYY")	
		dateinit=TB.DTN(annee$+"0101","YYYYMMDD")
		quantieme=dateval-dateinit+1
		datemask$=datemask$(1,x-1)+str(quantieme:"000")+datemask$(x+3)
	fi
        let x=pos("DD"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Dz"+datemask$(X+2)
        fi
        
        let x=pos("HH"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Hz"+datemask$(X+2)
        fi
        
        let x=pos("MI"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%mz"+datemask$(X+2)
        fi
        
        let x=pos("SS"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%sz"+datemask$(X+2)
        fi
        
        if datedec>0 
            ntd$=date(dateval+1721423,datedec:datemask$)
        else  
            ntd$=date(dateval+1721423:datemask$)
        endif 
        methodret ntd$
        NTDJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err
    methodend

    method public static BBjString CVT(BBjString stringa$, BBjNumber valore)

        seterr CVTJ_err
        if stringa$="" then methodret stringa$ endif 
        if valore>=8192 then
            let stringa$=swap(stringa$,$08$)
            valore=valore-8192
        fi
        
        if valore>=4096 then
            let stringa$=cvs(stringa$,8)
            valore=valore-4096
        fi
        
        if valore>=2048 then
            let stringa$=tbl(stringa$,$7F$)
            valore=valore-2048
        fi

       if valore>=1024 then
            if len(stringa$)=0 then
                valore=valore-1024
            fi
            let temp$=$$
            for x=1 to len(stringa$)
            if pos(stringa$(x,1)=" abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")<>0 then
                let temp$=temp$+stringa$(x,1)
            fi
            next x
            let stringa$=temp$
            valore=valore-1024
        fi
        
        if valore>=512 then
            let stringa$=swap(stringa$,$02$)
            valore=valore-512
        fi

        if valore>=256 then
            valore=valore-256
        fi

        if valore>=128 then
        let stringa$=cvs(stringa$,2)
            valore=valore-128
        fi

       if valore>=64 then
            if len(stringa$)=0 then
                valore=valore-64
            fi
            for x=1 to len(stringa$)
            if stringa$(x,1)="[" then
                let stringa$(x,1)="("
            fi
            if stringa$(x,1)="]" then
                let stringa$(x,1)=")"
            fi
            next x
            valore=valore-64
        fi

        if valore>=32 then
            let stringa$=cvs(stringa$,4)
            valore=valore-32
        fi
        
        if valore>=16 then
            let stringa$=cvs(stringa$,32)
            valore=valore-16
        fi
        
        if valore>=8 then
            let stringa$=cvs(stringa$,1)
            valore=valore-8
        fi

        if valore>=4 then
            let stringa$=cvs(stringa$,16)
            if len(stringa$)=0 then
                valore=valore-4
            fi
            let temp$=$$
            for x=1 to len(stringa$)
            if pos(stringa$(x,1)=$0920$)=0 then
                let temp$=temp$+stringa$(x,1)
            fi
            next x
            let stringa$=temp$
            valore=valore-4
        fi

        if valore>=2 then
            if len(stringa$)=0 then
                valore=valore-2
            fi
            let temp$=$$
            for x=1 to len(stringa$)
            if pos(stringa$(x,1)=$0920$)=0 then
                let temp$=temp$+stringa$(x,1)
            fi
            next x
            let stringa$=temp$
            valore=valore-2
        fi
        
        if valore=1 then
            let stringa$=tbl(stringa$,$7F$)
            valore=valore-1
        fi
        
        CVTJ_exit:
        methodret stringa$

        CVTJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber NMV(BBjString value$)

        seterr NMVJ_err

        let x=num(value$,err=NOT_NUM)
        methodret 1

        NOT_NUM:
        methodret 0

        NMVJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString ALLBBJ(BBjString value$, BBjString character$)

        seterr ALLJ_err

        dim temp$(len(value$),character$)
        if value$="" then
            let temp$="* * * String that should not match with anything, hopefully... :) * * *"
        fi
        methodret temp$

        ALLJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString TSK(BBjNumber channel)

        seterr TSKJ_err

        let devices$=""
        while x<100
            let temp$=tsk(x,err=TSKJ_exit)
            let devices$=devices$+temp$(3,2)+"    "
            let x=x+1
        wend
        goto TSKJ_exit

        TSKJ_exit:
        methodret devices$

        TSKJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString FID(BBjNumber channel)

        seterr FIDJ_err
        let temp$=fid(channel)
        if len(temp$)=2 or len(temp$)=3 then
            let fid_tbd$=temp$
            goto FIDJ_exit  
        fi
        
        dim fid_tbd$(20)
        let fid_tbd$(4,6)=temp$(pos("/"=temp$,-1)+1)
        rem added for infodev 
        rem returns TB filetype 
        rem vkeyed returns msort 
        switch 1
           case temp$(1,1)=$0D$;fid_tbd$(10,1)=$06$;break 
           case default;fid_tbd$(10,1)=temp$(1,1);break
        swend

        let rec_num=dec(temp$(3,4))
        let fid_tbd$(12,3)=bin(rec_num)
        let key_size=dec(temp$(2,1))
        if rec_num<32768 then
            let fid_tbd$(11,1)=bin(key_size+4)
        else
            let fid_tbd$(11,1)=bin(key_size+6)
        fi
        let fid_tbd$(15,2)=temp$(7,2)

        rem disk number         
        filepath$=temp$(9)
        numdsk=#NUMDSK(filepath$)

        rem changed to cut filenames longer than 6 in two to mimic TB FID
        if numdsk=-1 then 
          filepath$=PAD(filepath$,MAX(6,len(filepath$))," ")
          fid_tbd$(4,6)=filepath$
          fid_tbd$(20,1)=chr(0)  
          fid_tbd$=fid_tbd$+str(filepath$(7),err=*next)
        else 
          fid_tbd$(20,1)=chr(numdsk)
          filename$=filepath$(pos("/"=filepath$,-1,1)+1)
          filename$=PAD(filename$,MAX(6,len(filename$))," ")
          fid_tbd$(4,6)=filename$
          fid_tbd$=fid_tbd$+str(filename$(7),err=*next)         
        endif 
        FIDJ_exit:
        methodret fid_tbd$

        FIDJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber FILE(BBjString fid_tbd$)

        seterr FILEJ_err

        file fid_tbd$(23)
        methodret 0

        FILEJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber DIR(BBjString file_name$, BBjNumber key_size, BBjNumber num_rec, BBjNumber rec_size, BBjNumber disk_num, BBjNumber sec_num)

        seterr DIRJ_err

        mkeyed stbl("!ARCHIVI")+file_name$,key_size,0,rec_size
        methodret 0

        DIRJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber SOR(BBjString file_name$, BBjNumber key_size, BBjNumber num_rec, BBjNumber disk_num, BBjNumber sec_num)

        seterr SORJ_err

        mkeyed stbl("!ARCHIVI")+file_name$,key_size,0,0
        methodret 0

        SORJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber TEX(BBjString file_name$, BBjNumber disk_num, BBjNumber sec_num)

        seterr TEXJ_err

        if disk_num = 2 then
            string stbl("!ARCHIVI")+file_name$
        else
            string stbl("!ESPORTAZIONI")+file_name$
        fi

        methodret 0

        TEXJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString WGL(BBjNumber dummy)

        seterr WGLJ_err

        print (0) 'EE'+'CI'+'WINDOW'("LIST"),
        read record (0,siz=1) count$
        read record (0,siz=asc(count$)) list$
        print (0) 'BE',
        methodret list$

        WGLJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber WDA(BBjNumber dummy)

        seterr WDAJ_err

        list$=TB.WGL(0)
        for x=1 to len(list$)
            let win=dec(list$(x,1))
            if win then
                print 'DROP'(win)
            fi
        next x
        methodret 0

        WDAJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString E47(BBjString stringa$, BBjNumber offs, BBjNumber length)

        methodret str(stringa$(offs,length),err=*next)
        methodret ""

    methodend

    method public static BBjString E47(BBjString stringa$, BBjNumber offs)

        methodret str(stringa$(offs),err=*next)
        methodret ""

    methodend

    method public static BBjString GPH(BBjString stringa$, BBjString caratteri$)

        seterr GPHJ_err
        let stringa$=stringa$+$00$, car1$="", car2$="37584629:01", graph$=""
        for x=1 to len(caratteri$) step 3
            let car1$=car1$+chr(num(caratteri$(x,3)))
        next x
        while stringa$<>$00$
            let p=pos(stringa$(1,1)=car1$)
            if p<>0 then
                let graph$=graph$+'GS'+fill(pos(car1$(p,1)<>stringa$(2)),car2$(p,1))+'GE'
                let stringa$=stringa$(pos(car1$(p,1)<>stringa$))
            else
                let graph$=graph$+stringa$(1,1)
                let stringa$=stringa$(2)
            fi
        wend
        methodret graph$

        GPHJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

        methodend

    method public static BBjNumber WGN(BBjNumber dummy)

        seterr WGNJ_err

        list$=TB.WGL(0)
        methodret dec(list$(1,1))

        WGNJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber WDL(BBjString lista1$)

        seterr WDLJ_err

        lista2$=TB.WGL(0)
        for x=1 to len(lista2$)
            if pos(lista2$(x,1)=lista1$)=0 then
                let win=dec(lista2$(x,1))
                if win then
                    print @(0,0),'DROP'(win),
                fi
            fi
        next x
        methodret 0

        WDLJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend
    
    rem /* 
    rem *   LIKE
    rem */
    method public static Boolean LIKE(BBjString a!,BBjString b!) 
        rem /* map TBD regexpr to java 
        rem map ? to . 
        rem map [?] to \?
        rem map [*] to \*
        rem map [[] to \[
        rem replace * par .*
        rem */ 
        b! = b!.replaceAll("\[\*\]","\\*") 
        b! = b!.replaceAll("\[\?\]","\\?") 
        b! = b!.replaceAll("(?<!\\)\?",".")  
        b! = b!.replaceAll("\[\[\]","\\[") 
        b! = b!.replaceAll("(?<!\\)\*","\.\*") 
        methodret a!.matches(b!,err=*next)
        methodret BBjAPI().FALSE
    methodend 
    

        rem /* 
    rem * replaces the tb unt(filename$) function that retrieve the first channel on which the file was opened
    rem * @param the name of the file to retrieve the channel 
    rem * @return the first channel on which the file was opened 
    rem */ 
    method public static BBjNumber TBUNT(BBjString unt$) 
      LET UNT0$=CHN,UNT0=1
      UNT_LOOP:
      IF UNT0>LEN(UNT0$) THEN methodret 0
      LET UNT1=DEC(UNT0$(UNT0,2)),UNT1$=FID(UNT1)
      IF POS(UNT1$(1,1)=$000102030405060786$) AND UNT1$(9)=UNT$ THEN methodret UNT1
      LET UNT0=UNT0+2
      GOTO UNT_LOOP
    methodend 

        rem /*
    rem * For positive numbers, this numeric function returns the truncated integer portion of the number (the 
    rem *same as the INT function). For negative numbers, this function returns the integer portion of the number 
    rem *unconditionally rounded to the next smaller negative integer if the original negative number contained 
    rem *any fractional portion.
    rem reflect TB's FIX
    rem */ 
    method public static BBjNumber FIX(BBjNumber N)
        IF N<0 AND N<>INT(N) THEN LET N=INT(N-1) ELSE LET N=INT(N)
        methodret N
    methodend 

        rem /*
    rem * INFODEV, Christophe RICHARD
    rem * This function is design to simulate the Tbred logical disk
    rem * in the config.bbx we add some global vars like
    rem * SET !DSK_D0=/infodev/tmp/UTILBBJ/
    rem * SET !DSK_D4=/infodev/tmp/IFAGIV4/
    rem * ...
    rem * TB.REPDSK(DSK) is used to get the string directory from a number of disq
    rem * This string is used to create files 
    rem */
    method public static BBjString REPDSK(BBjNumber numdsk)
        methodret STBL("!DSK_D"+str(numdsk))
    methodend

    rem /*
    rem * INFODEV, Christophe RICHARD
    rem * This function is design to simulate the Tbred logical disk
    rem * in the config.bbx we add some global vars like
    rem * SET !DSK_D0=/infodev/tmp/UTILBBJ/
    rem * SET !DSK_D4=/infodev/tmp/IFAGIV4/
    rem * ...
    rem * TB.REPDSK(DSK) is used to get the string directory from a number of disq
    rem * This string is used to create files 
    rem */
    method public static BBjNumber NUMDSK(BBjString filepath$)
        numdsk=-1
        FOR dsk=0 to 9
            repdsk$=STBL("!DSK_D"+str(dsk),err=labnext)
            if pad(filepath$,len(repdsk$))=repdsk$ then numdsk=dsk; break
            labnext:
        NEXT dsk
        methodret numdsk
    methodend

    rem /*
    rem * addsort  
    rem */
    method public static void ADDSORT(BBjString file$, BBjString sortname$,BBjString keyChain$)
         seterr m_error
         rem #ToDo: add throw exception 17 if key already exists
            declare BBjFileInfo info! 

            ch=unt;open(ch)file$ 
            info! = #fileSystem!.getFileInfo(ch) 
            
            declare BBjKeyInfo keyInfo! 
            keyInfo! = #getKeyInfo(keyChain$) 
            info!.lock()
            info!.addKey(sortname$,keyInfo!)
            info!.unlock()
            close(ch)
        methodret
        m_error: 
         System.out.println("Error adding sort"+str(err)+str(tcb(5)))
    methodend 
    
        rem /*
    rem * addsort  
    rem */
    method public static void REMSORT(BBjString file$, BBjString sortname$)
         seterr remsort_error
            declare BBjFileInfo info! 
            
            ch=unt;open(ch)file$ 
            info! = #fileSystem!.getFileInfo(ch) 
            
            declare BBjKeyInfo keyInfo! 
            info!.lock()
            info!.dropKey(sortname$)
            info!.unlock()
            close(ch)
        methodret
        remsort_error: 
         System.out.println("Error removing sort"+str(err)+str(tcb(5)))
    methodend 

    method public static BBjKeyInfo getKeyInfo(BBjString keyDefinition$) 
        declare BBjVector keySegments! 
        keySegments! = bbjapi().makeVector()
        if len(keyDefinition$)=0 then methodret null() 
        if keyDefinition$(1,1) <>"[" then keyDefinition$=keyDefinition$(pos("["=keyDefinition$)) endif 
        declare String segments!
        dim segments![0]

        if pos("+"=keyDefinition$)>0 then 
            segments! = keyDefinition$
            segments![]=segments!.split("\+") 
        else 
            segments![0]=keyDefinition$
        endif 
        
        i=0
        while 1 
            tmpKeySegment$ = str(segments![i],err=*break)
            m_field=num(tmpKeySegment$(pos("["=tmpKeySegment$)+1,pos(":"=tmpKeySegment$)-((pos("["=tmpKeySegment$)+1))) )
            m_pos=num(tmpKeySegment$(pos(":"=tmpKeySegment$,1,1)+1,pos(":"=tmpKeySegment$,1,2)-((pos(":"=tmpKeySegment$,1,1)+1))) )
            if pos(":"=tmpKeySegment$,1,0)=2 then 
                m_len=num(tmpKeySegment$(pos(":"=tmpKeySegment$,1,2)+1,pos("]"=tmpKeySegment$)-((pos(":"=tmpKeySegment$,1,2)+1))) )
                m_desc!=bbjapi().FALSE
            else
                m_len=num( tmpKeySegment$(pos(":"=tmpKeySegment$,1,2)+1,pos(":"=tmpKeySegment$,1,3)-((pos(":"=tmpKeySegment$,1,2)+1))) )
                if pos("D"=tmpKeySegment$)>0 then 
                    m_desc!=bbjapi().TRUE
                else 
                    m_desc!=bbjapi().FALSE
                endif
            endif 
            rem m_pos add 1 at keySegmentCreation
            keySegment! = #fileSystem!.makeKeySegment(m_field,m_pos-1,m_len,m_desc!,BBjAPI().FALSE)
            keySegments!.add(keySegment!)            
            i=i+1
        wend 
            isUnique! = bbjapi().FALSE
            if pos("U"=tmpKeySegment$) then isUnique!=bbjapi().TRUE            
            keyInfo! = #fileSystem!.makeKeyInfo(keySegments!,isUnique!)
        methodret keyInfo!
        methodend 
    rem A D  ]:"U"
    rem /*
    rem * remsort 
    rem */ 
    method public static void REMSORT(BBjString fileName$,BBjString sortName$)
        seterr RemSortError
        declare BBjFileInfo info! 
        ch=unt 
        open(ch)fileName$ 
        info! = bbjapi().getFileSystem().getFileInfo(ch) 
        info!.lock() 
        info!.dropKey(sortName$)
        info!.unlock()
        close(ch)
        methodret 
        RemSortError: 
            System.out.println("error removing index:"+fileName$+ " "+sortName$)
    methodend 

    rem change keyname or set keyname for first key 
    method public static void setKeyName(BBjString fileName$,BBjString oldKeyName$,BBjString newKeyName$)
        ch=unt 
        open(ch)filename$
        declare BBjFileInfo info! 
        info! = bbjapi().getFileSystem().getFileInfo(ch)
        info!.lock() 
        info!.setKeyName(oldKeyName$,newKeyName$,err=*next);info!.unlock();close(ch); methodret 
        info!.setKeyName(0,newKeyName$) 
        info!.unlock()
        close(ch)         
    methodend     
     
    method public static void setKeyName(BBjString fileName$,BBjNumber keyIndex,BBjString newKeyName$)
        ch=unt 
        open(ch)filename$
        declare BBjFileInfo info! 
        info! = bbjapi().getFileSystem().getFileInfo(ch) 
        info!.lock()
        info!.setKeyName(keyIndex,newKeyName$,err=*next) 
        info!.unlock()
        close(ch)
REM         info!.setKeyName(0,newKeyName$) 
    methodend     

     
    rem /* 
    rem *
    rem * allbbj 
    rem * checks if string is composed of char
    rem *
    rem */ 
    method public static boolean ALLBBj(BBjString input$,BBjString compareString$)
        seterr not_equal
        if input$=FILL(len(input$),compareString$(1,1)) then methodret bbjapi().TRUE endif 
        not_equal: 
        methodret bbjapi().FALSE
    methodend  
    
    
    method public static BBjString DSD(BBjString dev$) 
	SETERR ERR_DSD
	if #LIKE(dev$,"D?") then
        	dim fid$(86)
		fid$(1,2)=dev$
		fid$(6,1)=$00$
		fid$(23)=STBL("!DSK_"+dev$)
	else
        	dim fid$(72)
        	fid$(1)=fid(0) 
        	if dev$=fid(0) then 
            		dev$=fid$(1,2) 
        	endif 
        	fid$(11,8)=stbl("!ID_TERM",err=*next)
	endif
        methodret fid$
	ERR_DSD:
	methodret ""
    methodend 
    
    method public static BBjString XFD(BBjNumber channel,BBjNumber func)
REM         XFD(canal_fichier,3) :  key definition data for MSORT and TISAM files
REM         XFD(45,1)     = longueur clé principale
REM         XFD(48,20)   = nom du tri principal
        dim xfd$(100) 
        declare BBjFileInfo info! 
        info! = bbjapi().getFileSystem().getFileInfo(channel)
        keyLen = #getKeyLen(info!.getKeyInfo(0).getKeySegments())        
        xfd$(45,1)=chr(keyLen)
        xfd$(48,20)=info!.getKeyName(0,err=*next)
        methodret xfd$
    methodend 
    
    method public static BBjNumber getKeyLen(BBjVector keySegments!) 
        keyLen=0
        for i=0 to keySegments!.size()-1
            keyLen=keyLen+cast(BBjKeySegment,keySegments!.get(i)).getLength() 
        next i
        methodret keyLen
    methodend 
classend



rem #TODO: add TB.killSession to kill  another session replace RELEASE XY$ -> TB.killSession(XY$)
