use com.basis.api.admin.BBjAdminFactory
use com.basis.api.admin.BBjAdminBase
use com.basis.api.admin.BBjAdminOpenFile
use java.util.List
use java.util.Iterator
use java.net.InetAddress
use java.util.GregorianCalendar
use java.util.Calendar
use java.io.File


class public TB


    field public static BBjFileSystem fileSystem! = bbjapi().getFileSystem() 

    method public static BBjNumber UNT0(BBjString fichier$)
	canal=0
	SETERR UNT_END
	C=UNT; OPEN (C,ERR=UNT_END) fichier$
	fichier$=CVS(FID(C)(9),2)
	CLOSE(C)
	lcan$=CHN
	i=1
	WHILE (i < LEN(LCAN$) )
		canalt=DEC($00$+lcan$(i,2))
		if canalt > 0 then
			fichier0$ = cvs(FID(canalt)(9),2)
			if (fichier$ = fichier0$) then
				canal=canalt
				break
			fi
		fi
		i=i+2
	WEND
	UNT_END:
	methodret canal
    methodend

    method public static BBjNumber DTN(BBjString dateval$, BBjString datemask$)
        seterr DTNJ_err
        prc=tcb(14)
        PRECISION 8


        let dt$=$$, mk$=$$, datemask$=cvs(datemask$,4)

        let x=pos("YYYY"=datemask$)
        if x<>0 then
            let dt$=dt$+dateval$(x,4), mk$=mk$+"%Yl", datemask$(x,4)="xxxx"
        fi

        let x=pos("YY"=datemask$)
        if x<>0 then
            if num(dateval$(x,2))>50 then
                let dt$=dt$+"19"+dateval$(x,2)
            else
                let dt$=dt$+"20"+dateval$(x,2)
            fi
            let mk$=mk$+"%Yl", datemask$(x,2)="xx"
        fi

        let x=pos("DDD"=datemask$)
        if x<>0 then
            mk$=mk$+"%Mz%Dz", datemask$(x,3)="xxx"
            declare GregorianCalendar gc! 
            gc! = new java.util.GregorianCalendar() 
            gc!.set(Calendar.DAY_OF_YEAR,num(dateval$(x,3)))
            gc!.set(Calendar.YEAR,num(dt$))
            dt$=dt$+str(gc!.get(Calendar.MONTH)+1:"00")+str(gc!.get(Calendar.DAY_OF_MONTH))
            goto return_dtn
        fi    


        let x=pos("MM"=datemask$)
        if x<>0 then
            let dt$=dt$+dateval$(x,2), mk$=mk$+"%Mz", datemask$(x,2)="xx"
        else
            let dt$=dt$+"01", mk$=mk$+"%Mz"
        fi

        let x=pos("DD"=datemask$)
        if x<>0 then
            let dt$=dt$+dateval$(x,2), mk$=mk$+"%Dz", datemask$(x,2)="xx"
        else
            let dt$=dt$+"01", mk$=mk$+"%Dz"
        fi

        datedec=0

        let x=pos("HH"=datemask$)
        if x<>0 then
            let datedec=num(dateval$(x,2))/24
        fi

        let x=pos("MI"=datemask$)
        if x<>0 then
            let datedec=datedec+num(dateval$(x,2))/24/60
        fi

                let x=pos("SS"=datemask$)
        if x<>0 then
            let datedec=datedec+num(dateval$(x,2))/24/60/60
        fi

                return_dtn:
        PRECISION prc
        dtn = jul(dt$,mk$)-1721423
        methodret dtn+datedec

        DTNJ_err:
        PRECISION prc
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend



    method public static BBjString NTD(BBjNumber dateval, BBjString datemask$)
REM         seterr NTDJ_err
        declare String datemask!
        datemask!=datemask$


        if dateval=0 then 
            dateval=JUL(0,0,0)-1721423
            datedec=TIM
        else    
            datedec=mod(dateval,1)
            dateval=dateval-datedec
            datedec=datedec*24   
        endif

           let x=pos("YYYY"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Yl"+datemask$(X+4)
        fi

        let x=pos("YY"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Yz"+datemask$(X+2)
        fi

        let x=pos("MM"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Mz"+datemask$(X+2)
        fi

        uppercase=0

        let x=pos("MON"=datemask$)
        if x<>0 then
             uppercase=1
             datemask! = datemask$
             let datemask$=datemask!.replaceAll("MON","%Ms")
        fi

        let x=pos("Dy"=datemask$)
        if x<>0 then
             datemask! = datemask$
             let datemask$=datemask!.replaceAll("Dy","%Ds")
        fi

        let x=pos("DY"=datemask$)
        if x<>0 then
             uppercase=1
             datemask! = datemask$
             let datemask$=datemask!.replaceAll("DY","%Ds")
        fi



	let x=pos("DDD"=datemask$)
	if x<>0 then
		annee$=TB.NTD(dateval,"YYYY")	
		dateinit=TB.DTN(annee$+"0101","YYYYMMDD")
		quantieme=dateval-dateinit+1
		datemask$=datemask$(1,x-1)+str(quantieme:"000")+datemask$(x+3)
	fi
        let x=pos("DD"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Dz"+datemask$(X+2)
        fi

        let x=pos("HH"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%Hz"+datemask$(X+2)
        fi
        let x=pos("MI"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%mz"+datemask$(X+2)
        fi

        let x=pos("SS"=datemask$)
        if x<>0 then
            let datemask$=datemask$(1,x-1)+"%sz"+datemask$(X+2)
        fi

        let x=pos("SSSSSS"=datemask$)
        if x<>0 then
            datedec$=""
            datedecval=datedec*60*60
            datedecval=mod(datedecval,1)
            datedec=round(datedec-(datedecval/10000),4)

                        datemask!=datemask$
            datemask$=datemask!.replaceAll(".SSSSSS","")
            if datedec>0 then 
                datedec$=str(datedecval:".000000")
            endif 

                   fi

                datemask! = datemask$ 
        datemask$ = datemask!.replaceAll("Day","%Dl")

                if datedec>0 
            ntd$=date(num(str(dateval+1721423)),datedec:datemask$)+datedec$
        else  
            ntd$=date(num(str(dateval+1721423)):datemask$)+datedec$
        endif 



                return_tnd:
        if uppercase then ntd$=cvs(ntd$,4)
        methodret ntd$
        NTDJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err
    methodend

    method public static BBjString CVT(BBjString stringa$, BBjNumber valore)

        seterr CVTJ_err
        if stringa$="" then methodret stringa$ endif 
        if valore>=8192 then
            let stringa$=swap(stringa$,$08$)
            valore=valore-8192
        fi

                if valore>=4096 then
            let stringa$=cvs(stringa$,8)
            valore=valore-4096
        fi

                if valore>=2048 then
            let stringa$=tbl(stringa$,$7F$)
            valore=valore-2048
        fi

       if valore>=1024 then
            if len(stringa$)=0 then
                valore=valore-1024
            fi
            let temp$=$$
            for x=1 to len(stringa$)
            if pos(stringa$(x,1)=" abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")<>0 then
                let temp$=temp$+stringa$(x,1)
            fi
            next x
            let stringa$=temp$
            valore=valore-1024
        fi

                if valore>=512 then
            let stringa$=swap(stringa$,$02$)
            valore=valore-512
        fi

        if valore>=256 then
            valore=valore-256
        fi

        if valore>=128 then
        let stringa$=cvs(stringa$,2)
            valore=valore-128
        fi

       if valore>=64 then
            if len(stringa$)=0 then
                valore=valore-64
            fi
            for x=1 to len(stringa$)
            if stringa$(x,1)="[" then
                let stringa$(x,1)="("
            fi
            if stringa$(x,1)="]" then
                let stringa$(x,1)=")"
            fi
            next x
            valore=valore-64
        fi

        if valore>=32 then
            let stringa$=cvs(stringa$,4)
            valore=valore-32
        fi

                if valore>=16 then
            let stringa$=cvs(stringa$,32)
            valore=valore-16
        fi

                if valore>=8 then
            let stringa$=cvs(stringa$,1)
            valore=valore-8
        fi

        if valore>=4 then
            let stringa$=cvs(stringa$,16)
            if len(stringa$)=0 then
                valore=valore-4
            fi
            let temp$=$$
            for x=1 to len(stringa$)
            if pos(stringa$(x,1)=$0920$)=0 then
                let temp$=temp$+stringa$(x,1)
            fi
            next x
            let stringa$=temp$
            valore=valore-4
        fi

        if valore>=2 then
            stringa$=cvs(stringa$,144)  
            valore=valore-2
        fi

                if valore=1 then
            let stringa$=tbl(stringa$,$7F$)
            valore=valore-1
        fi

                CVTJ_exit:
        methodret stringa$

        CVTJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber NMV(BBjString value$)

        seterr NMVJ_err

        let x=num(value$,err=NOT_NUM)
        methodret 1

        NOT_NUM:
        methodret 0

        NMVJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString ALLBBJ(BBjString value$, BBjString character$)

        seterr ALLJ_err

        dim temp$(len(value$),character$)
        if value$="" then
            let temp$="* * * String that should not match with anything, hopefully... :) * * *"
        fi
        methodret temp$

        ALLJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString TSK(BBjNumber channel)

        seterr TSKJ_err

        if channel=0 then 
        let devices$=""
        while x<100
            let temp$=tsk(x,err=TSKJ_exit)
            let devices$=devices$+temp$(3,2)+"    "
            let x=x+1
        wend
       else 

                   endif  


        goto TSKJ_exit

        TSKJ_exit:
        methodret devices$

        TSKJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString FID(BBjNumber channel)

        seterr FIDJ_err
        let temp$=fid(channel)
        if len(temp$)=2 or len(temp$)=3 then
            let fid_tbd$=temp$
            goto FIDJ_exit  
        fi

        dim fid_tbd$(20)
        let fid_tbd$(4,6)=temp$(pos("/"=temp$,-1)+1)
        rem added for infodev 
        rem returns TB filetype 
        rem vkeyed returns msort 
        switch 1
           case temp$(1,1)=$0D$;fid_tbd$(10,1)=$06$;break 
           case default;fid_tbd$(10,1)=temp$(1,1);break
        swend

        let rec_num=dec(temp$(3,4))
        let fid_tbd$(12,3)=bin(rec_num)
        let key_size=dec(temp$(2,1))
        if rec_num<32768 then
            let fid_tbd$(11,1)=bin(key_size+4)
        else
            let fid_tbd$(11,1)=bin(key_size+6)
        fi
        let fid_tbd$(15,2)=temp$(7,2)

        rem disk number         
        filepath$=temp$(9)
        numdsk=#NUMDSK(filepath$)

        rem changed to cut filenames longer than 6 in two to mimic TB FID
        if numdsk=-1 then 
          filepath$=PAD(filepath$,MAX(6,len(filepath$))," ")
          fid_tbd$(4,6)=filepath$
          fid_tbd$(20,1)=chr(0)  
          fid_tbd$=fid_tbd$+str(filepath$(7),err=*next)
        else 
          fid_tbd$(20,1)=chr(numdsk)
          filename$=filepath$(pos("/"=filepath$,-1,1)+1)
          filename$=PAD(filename$,MAX(6,len(filename$))," ")
          fid_tbd$(4,6)=filename$
          fid_tbd$=fid_tbd$+str(filename$(7),err=*next)         
        endif 
        FIDJ_exit:
        methodret fid_tbd$

        FIDJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber FILE(BBjString fid_tbd$)

        seterr FILEJ_err

        file fid_tbd$(23)
        methodret 0

        FILEJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber DIR(BBjString file_name$, BBjNumber key_size, BBjNumber num_rec, BBjNumber rec_size, BBjNumber disk_num, BBjNumber sec_num)

        seterr DIRJ_err

        mkeyed stbl("!ARCHIVI")+file_name$,key_size,0,rec_size
        methodret 0

        DIRJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber SOR(BBjString file_name$, BBjNumber key_size, BBjNumber num_rec, BBjNumber disk_num, BBjNumber sec_num)

        seterr SORJ_err

        mkeyed stbl("!ARCHIVI")+file_name$,key_size,0,0
        methodret 0

        SORJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber TEX(BBjString file_name$, BBjNumber disk_num, BBjNumber sec_num)

        seterr TEXJ_err

        if disk_num = 2 then
            string stbl("!ARCHIVI")+file_name$
        else
            string stbl("!ESPORTAZIONI")+file_name$
        fi

        methodret 0

        TEXJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString WGL(BBjNumber dummy)

        seterr WGLJ_err

        print (0) 'EE'+'CI'+'WINDOW'("LIST"),
        read record (0,siz=1) count$
        read record (0,siz=asc(count$)) list$
        print (0) 'BE',
        methodret list$

        WGLJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber WDA(BBjNumber dummy)

        seterr WDAJ_err

        list$=TB.WGL(0)
        for x=1 to len(list$)
            let win=dec(list$(x,1))
            if win then
                print 'DROP'(win)
            fi
        next x
        methodret 0

        WDAJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjString E47(BBjString stringa$, BBjNumber offs, BBjNumber length)

        methodret str(stringa$(offs,length),err=*next)
        methodret ""

    methodend

    method public static BBjString E47(BBjString stringa$, BBjNumber offs)

        methodret str(stringa$(offs),err=*next)
        methodret ""

    methodend

    method public static BBjString GPH(BBjString stringa$, BBjString caratteri$)

        seterr GPHJ_err
        let stringa$=stringa$+$00$, car1$="", car2$="37584629:01", graph$=""
        for x=1 to len(caratteri$) step 3
            let car1$=car1$+chr(num(caratteri$(x,3)))
        next x
        while stringa$<>$00$
            let p=pos(stringa$(1,1)=car1$)
            if p<>0 then
                let graph$=graph$+'GS'+fill(pos(car1$(p,1)<>stringa$(2)),car2$(p,1))+'GE'
                let stringa$=stringa$(pos(car1$(p,1)<>stringa$))
            else
                let graph$=graph$+stringa$(1,1)
                let stringa$=stringa$(2)
            fi
        wend
        methodret graph$

        GPHJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

        methodend

    method public static BBjNumber WGN(BBjNumber dummy)

        seterr WGNJ_err

        list$=TB.WGL(0)
        methodret dec(list$(1,1))

        WGNJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

    method public static BBjNumber WDL(BBjString lista1$)

        seterr WDLJ_err

        lista2$=TB.WGL(0)
        for x=1 to len(lista2$)
            if pos(lista2$(x,1)=lista1$)=0 then
                let win=dec(lista2$(x,1))
                if win then
                    print @(0,0),'DROP'(win),
                fi
            fi
        next x
        methodret 0

        WDLJ_err:
        throw errmes(-1)+" in class TB at line "+str(tcb(5)),err

    methodend

        rem /* 
    rem *   LIKE
    rem */
    method public static Boolean LIKE(BBjString a!,BBjString b!) 
        rem /* map TBD regexpr to java 
        rem map ? to . 
        rem map [?] to \?
        rem map [*] to \*
        rem map [[] to \[
        rem replace * par .*
        rem */ 
        b! = b!.replaceAll("\\","\\\\")
        b! = b!.replaceAll("\[\*\]","\\*") 
        b! = b!.replaceAll("\[\?\]","\\?") 
        b! = b!.replaceAll("(?<!\\)\?",".")  
        b! = b!.replaceAll("\[\[\]","\\[") 
        b! = b!.replaceAll("(?<!\\)\*","\.\*") 
        b! = b!.replaceAll("\(","\\\(")
        b! = b!.replaceAll("\)","\\\)")
        methodret a!.matches(b!,err=*next)
        methodret BBjAPI().FALSE
    methodend 


        rem /* 
    rem * replaces the tb unt(filename$) function that retrieve the first channel on which the file was opened
    rem * @param the name of the file to retrieve the channel 
    rem * @return the first channel on which the file was opened 
    rem */ 
    method public static BBjNumber TBUNT(BBjString unt$) 
      LET UNT0$=CHN,UNT0=1
      UNT_LOOP:
      IF UNT0>LEN(UNT0$) THEN methodret 0
      LET UNT1=DEC(UNT0$(UNT0,2)),UNT1$=FID(UNT1)
      IF POS(UNT1$(1,1)=$000102030405060786$) AND UNT1$(9)=UNT$ THEN methodret UNT1
      LET UNT0=UNT0+2
      GOTO UNT_LOOP
    methodend 

        rem /*
    rem * For positive numbers, this numeric function returns the truncated integer portion of the number (the 
    rem *same as the INT function). For negative numbers, this function returns the integer portion of the number 
    rem *unconditionally rounded to the next smaller negative integer if the original negative number contained 
    rem *any fractional portion.
    rem reflect TB's FIX
    rem */ 
    method public static BBjNumber FIX(BBjNumber N)
        IF N<0 AND N<>INT(N) THEN LET N=INT(N-1) ELSE LET N=INT(N)
        methodret N
    methodend 

        rem /*
    rem * INFODEV, Christophe RICHARD
    rem * This function is design to simulate the Tbred logical disk
    rem * in the config.bbx we add some global vars like
    rem * SET !DSK_D0=/infodev/tmp/UTILBBJ/
    rem * SET !DSK_D4=/infodev/tmp/IFAGIV4/
    rem * ...
    rem * TB.REPDSK(DSK) is used to get the string directory from a number of disq
    rem * This string is used to create files 
    rem */
    method public static BBjString REPDSK(BBjNumber numdsk)
        methodret STBL("!DSK_D"+str(numdsk))
    methodend

    rem /*
    rem * INFODEV, Christophe RICHARD
    rem * This function is design to simulate the Tbred logical disk
    rem * in the config.bbx we add some global vars like
    rem * SET !DSK_D0=/infodev/tmp/UTILBBJ/
    rem * SET !DSK_D4=/infodev/tmp/IFAGIV4/
    rem * ...
    rem * TB.REPDSK(DSK) is used to get the string directory from a number of disq
    rem * This string is used to create files 
    rem */
    method public static BBjNumber NUMDSK(BBjString filepath$)
        numdsk=-1
	if len(filepath$)>0 AND filepath$(LEN(filepath$),1)<>"/" THEN
	filepath$=filepath$+"/"
	fi
        FOR dsk=0 to 9
            repdsk$=STBL("!DSK_D"+str(dsk),err=labnext)
            if pad(filepath$,len(repdsk$))=repdsk$ then numdsk=dsk; break
            labnext:
        NEXT dsk
        methodret numdsk
    methodend

    rem /*
    rem * addsort  
    rem */
    method public static void ADDSORT(BBjString file$, BBjString sortname$,BBjString keyChain$)
         seterr m_error
         rem #ToDo: add throw exception 17 if key already exists
            declare BBjFileInfo info! 

            ch=unt;open(ch)file$ 
            info! = #fileSystem!.getFileInfo(ch) 

                        declare BBjKeyInfo keyInfo! 
            keyInfo! = #getKeyInfo(keyChain$) 
            info!.lock()
            info!.addKey(sortname$,keyInfo!)
            info!.unlock()
            close(ch)
        methodret
        m_error: 
         System.out.println("Error adding sort"+str(err)+str(tcb(5)))
    methodend 

            rem /*
    rem * addsort  
    rem */
    method public static void REMSORT(BBjString file$, BBjString sortname$)
         seterr remsort_error
            declare BBjFileInfo info! 

                        ch=unt;open(ch)file$ 
            info! = #fileSystem!.getFileInfo(ch) 

                        declare BBjKeyInfo keyInfo! 
            info!.lock()
            info!.dropKey(sortname$)
            info!.unlock()
            close(ch)
        methodret
        remsort_error: 
         System.out.println("Error removing sort"+str(err)+str(tcb(5)))
    methodend 

    method public static BBjKeyInfo getKeyInfo(BBjString keyDefinition$) 
        declare BBjVector keySegments! 
        keySegments! = bbjapi().makeVector()
        if len(keyDefinition$)=0 then methodret null() 
        if keyDefinition$(1,1) <>"[" then keyDefinition$=keyDefinition$(pos("["=keyDefinition$)) endif 
        declare String segments!
        dim segments![0]

        if pos("+"=keyDefinition$)>0 then 
            segments! = keyDefinition$
            segments![]=segments!.split("\+") 
        else 
            segments![0]=keyDefinition$
        endif 

                i=0
        while 1 
            tmpKeySegment$ = str(segments![i],err=*break)
            m_field=num(tmpKeySegment$(pos("["=tmpKeySegment$)+1,pos(":"=tmpKeySegment$)-((pos("["=tmpKeySegment$)+1))) )
            m_pos=num(tmpKeySegment$(pos(":"=tmpKeySegment$,1,1)+1,pos(":"=tmpKeySegment$,1,2)-((pos(":"=tmpKeySegment$,1,1)+1))) )
            if pos(":"=tmpKeySegment$,1,0)=2 then 
                m_len=num(tmpKeySegment$(pos(":"=tmpKeySegment$,1,2)+1,pos("]"=tmpKeySegment$)-((pos(":"=tmpKeySegment$,1,2)+1))) )
                m_desc!=bbjapi().FALSE
            else
                m_len=num( tmpKeySegment$(pos(":"=tmpKeySegment$,1,2)+1,pos(":"=tmpKeySegment$,1,3)-((pos(":"=tmpKeySegment$,1,2)+1))) )
                if pos("D"=tmpKeySegment$)>0 then 
                    m_desc!=bbjapi().TRUE
                else 
                    m_desc!=bbjapi().FALSE
                endif
            endif 
            rem m_pos add 1 at keySegmentCreation
            keySegment! = #fileSystem!.makeKeySegment(m_field,m_pos-1,m_len,m_desc!,BBjAPI().FALSE)
            keySegments!.add(keySegment!)            
            i=i+1
        wend 
            isUnique! = bbjapi().FALSE
            if pos("U"=tmpKeySegment$) then isUnique!=bbjapi().TRUE            
            keyInfo! = #fileSystem!.makeKeyInfo(keySegments!,isUnique!)
        methodret keyInfo!
        methodend 
    rem A D  ]:"U"
    rem /*
    rem * remsort 
    rem */ 
    method public static void REMSORT(BBjString fileName$,BBjString sortName$)
        seterr RemSortError
        declare BBjFileInfo info! 
        ch=unt 
        open(ch)fileName$ 
        info! = bbjapi().getFileSystem().getFileInfo(ch) 
        info!.lock() 
        info!.dropKey(sortName$)
        info!.unlock()
        close(ch)
        methodret 
        RemSortError: 
            System.out.println("error removing index:"+fileName$+ " "+sortName$)
    methodend 

    rem change keyname or set keyname for first key 
    method public static void setKeyName(BBjString fileName$,BBjString oldKeyName$,BBjString newKeyName$)
        ch=unt 
        open(ch)filename$
        declare BBjFileInfo info! 
        info! = bbjapi().getFileSystem().getFileInfo(ch)
        info!.lock() 
        info!.setKeyName(oldKeyName$,newKeyName$,err=*next);info!.unlock();close(ch); methodret 
        info!.setKeyName(0,newKeyName$) 
        info!.unlock()
        close(ch)         
    methodend     

         method public static void setKeyName(BBjString fileName$,BBjNumber keyIndex,BBjString newKeyName$)
        ch=unt 
        open(ch)filename$
        declare BBjFileInfo info! 
        info! = bbjapi().getFileSystem().getFileInfo(ch) 
        info!.lock()
        info!.setKeyName(keyIndex,newKeyName$,err=*next) 
        info!.unlock()
        close(ch)
REM         info!.setKeyName(0,newKeyName$) 
    methodend     


    rem /* 
    rem *
    rem * allbbj 
    rem * checks if string is composed of char
    rem *
    rem */ 
    method public static boolean ALLBBj(BBjString input$,BBjString compareString$)
        seterr not_equal
        if input$="" and compareString$>"" then methodret bbjapi().FALSE endif 
        if input$=FILL(len(input$),compareString$(1,1)) then methodret bbjapi().TRUE endif 
        not_equal: 
        methodret bbjapi().FALSE
    methodend  


    method public static BBjString DSD(BBjString dev$) 
	SETERR ERR_DSD
	if #LIKE(dev$,"D?") then
        dim fid$(86)
		fid$(1,2)=dev$
		fid$(6,1)=$00$
		fid$(23)=STBL("!DSK_"+dev$)
	else
        	dim fid$(72)
        	fid$(1)=fid(0) 
        	if dev$=fid(0) then 
            	dev$=fid$(1,2) 
        	endif 
        	fid$(11,8)=stbl("!ID_TERM",err=*next)
	endif
        methodret fid$
	ERR_DSD:
	methodret ""
    methodend 

    method public static BBjString XFD(BBjNumber channel,BBjNumber func)
REM     XFD(canal_fichier,3) :  key definition data for MSORT and TISAM files
REM     XFD(45,1)     = longueur clé principale
REM     XFD(48,20)   = nom du tri principal
        dim xfd$(100) 
        declare BBjFileInfo info! 
        info! = bbjapi().getFileSystem().getFileInfo(channel)

        declare LinuxFileInfo lFileInfo!
        lFileInfo! = new LinuxFileInfo(file$) 


        switch func 
        case 0 
            xfd$(3,8)=bin(lFileInfo!.getInode())
            xfd$(38,4)=bin(lFileInfo!.getFileSize())
            xfd$(54,6)=bin(lFileInfo!.getLastChange())
            xfd$(60,6)=bin(lFileInfo!.getLastAccess())
            rem todo: handle large files
            break 
        case 1 
            break 
        case 2 
            break 
        case 3 
          dim xfd$(44)
          xfd$=fill(44,$00$)
          
          xfd$(1,1)=$01$
          
          bbjFileType$=bin(info!.getFileType())     
          switch 1
          case bbjfiletype$=$84$;xfd$(2,1)=$04$;break
          case bbjfiletype$>=$20$;xfd$(2,1)=$06$;break
          rem $00$ to $04$ default 
          case default; xfd$(2,1)=bbjFileType$;break
          swend 

          declare BBjVector keyVector! 
          keyVector! = info!.getKeyInfo(err=*next)           
          numKeys=0
          numKeys=keyVector!.size(err=*next) 
          xfd$(3,1)=bin(numKeys)

          currentKey=0
          currentKey=info!.getCurrentKeyNumber(err=*next)
          xfd$(4,1)=bin(currentKey)

                    xfd$(5,1)="N"

                    xfd$(6,1)="N"
          if bbjFileType$=$00$ then xfd$(6,1)="Y" endif 

                    xfd$(7,1)="Y"

          rem todo: 13-14 Index node size for MSORT and TISAM files; unsigned binary
          rem 15-16 not used The minimum record size (COBOL files only)
          rem todo: 17 Duplicate number width for MSORT and TISAM files
          rem todo: 18-19 Current commit counter ?
          rem todo: 20-21 Channel's commit count, non-zero if overridden by the CTC=option, otherwise zero
          rem todo: 22-45 unused 

          declare BBjVector keys! 
          keys! = info!.getKeyInfo() 
          
          for numKey=0 to keys!.size()-1  
          
            dim keyInfo$(39) 
            keyInfo$=fill(39,$00$)
            declare BBjKeyInfo keyInfo!          
    
            keyInfo! = info!.getKeyInfo(numKey)
            keyLen = #getKeyLen(keyInfo!.getKeySegments())        
  
            keySegments! = keyInfo!.getKeySegments()
            numSegments=keySegments!.size()   
            
  
            rem todo: check 45,1
            keyInfo$(1,1)=bin(keyLen)
            keyInfo$(2,1)=bin(numSegments)
            keyInfo$(3,1)=$00$ 
            keyName$=str(numKey)
            if info!.getKeyName(0,err=*next)<>null() then keyName$=info!.getKeyName(numKey) endif 
            keyInfo$(4,20)=keyName$+fill(20-len(keyName$),$00$)
            rem todo: byte 24 = Key may be modified
            keyInfo$(24,1)="Y"
            keyInfo$(25,1)="N"
            rem if keyInfo!.isUnique() then keyInfo$(25,1)="Y" else keyInfo$(25,1)="N" endif 
            rem bytes 27,5 = Unused
            rem todo: byte 32 = Field number (0 = no field number specified), unsigned binary get fieldnumber
            rem 33,6 not used
            
                   

            for numSegement=0 to numSegments-1            
              keySegment! = keySegments!.get(numSegement)
              dim segmentInfo$(8)
              segmentInfo$=fill(8,$00$)
              segmentInfo$(1,1)=bin(keySegment!.getField())
              segmentInfo$(2,2)=ath(str(keySegment!.getOffset()+1:"0000"))
              segmentInfo$(4,1)=bin(keySegment!.getLength())    
              if keySegment!.isDescending() then segmentInfo$(5,1)="D" else segmentInfo$(5,1)="A" endif 
              
              keyInfo$=keyInfo$+segmentInfo$
            next numSegement
            xfd$=xfd$+keyInfo$
          next numKey
                      break 
        case 5 
            break 
        case 6 
            break 
        case 10 
            break 
        swend 




        methodret xfd$
    methodend 

    method public static BBjNumber getKeyLen(BBjVector keySegments!) 
        keyLen=0
        for i=0 to keySegments!.size()-1
            keyLen=keyLen+cast(BBjKeySegment,keySegments!.get(i)).getLength() 
        next i
        methodret keyLen
    methodend 

    method public static void killSession(BBjString ses$) 
        seterr killError 
        if ses$="" then methodret 
        declare BBjVector sessions!  

                sessions! = bbjapi().getSessionInfos()

                for i=0 to sessions!.size()-1 
            if pos(ses$=cast(BBjSessionInfo, sessions!.get(i)).getIPAddress())>0 then 
                bbjapi().killSession(cast(BBjSessionInfo, sessions!.get(i)),"admin","admin123")
                methodret
            endif 
        next i
        methodret
        killError: 
        System.out.println("Error killing session"+str(err)+str(tcb(5)))
    methodend 


    rem closeAll 
    method public static void closeAll() 
        declare InetAddress addr! 
        addr! = InetAddress.getByName("127.0.0.1") 

        declare BBjAdminBase AdminBase! 
        AdminBase! = BBjAdminFactory.getBBjAdmin(addr!,2002,BBjAPI().FALSE,100,"admin","admin123")

        declare java.util.List openFiles! 
        openFiles! = AdminBase!.getOpenFiles()

        declare Iterator it!
        it!=openFiles!.iterator()
        mid=dec(info(3,0))
        declare BBjAdminOpenFile tmpFile! 
        if it!<>null() then 
            while it!.hasNext()
                tmpFile! = cast(BBjAdminOpenFile, it!.next()) 
                idString$ = tmpFile!.getProperties().get("id")
                fileOpenId=num(idString$(pos(":"=idString$)+1),err=*continue)
                if fileOpenId=mid then 
                    tmpFile!.forceClose()
                endif 
            wend 
        endif 

       methodend 

      method public static BBjString FST(BBjString file$, BBjNumber option) 
        seterr FSTError
        ch=unt
        open(ch)file$ 
        mfid$=fid(ch)
        close(ch)

                dim fst$(118)
        if option=1 then 
          rem 1-2
          fst$(1)=$0020$
          rem 3-4 
          fst$(3,2)=$0000$
          rem 5-6 file type 
          bbjFileType$=mfid$(1,1) 
          fst$(5,1)=$00$      
          switch 1
          case bbjfiletype$=$05$;fst$(6,1)=$0A$;break
          case bbjfiletype$>=$20$;fst$(6,1)=$06$;break
          rem $00$ to $04$ default 
          case default; fst$(6,1)=bbjFileType$
          swend 
        endif 

                rem *nix OS 
        ch=unt 
        open(ch)"| /usr/bin/stat "+file$ 
        while 1 
            read(ch,end=*break)tmpFileInfo$ 

                        if pos("File:"=tmpFileInfo$,1,1)>0 and pos("->"=tmpFileInfo$,1,1)>0 then 
                filePath$=tmpFileInfo$(pos("`"=tmpFileInfo$,1,2)+1,pos("'"=tmpFileInfo$,1,2)-(pos("`"=tmpFileInfo$,1,2)+1))
                continue
            endif 

                        rem device infomation 
           if tmpFileInfo$(1,6)="Device" then 
             device$=tmpFileInfo$(pos(" "=tmpFileInfo$,1,1)+1,pos("/"=tmpFileInfo$,1,1)-pos(" "=tmpFileInfo$,1,1)-2)
             fst$(11,4)=ath(fill(8-len(device$),"0")+device$)

                          inode$=tmpFileInfo$(pos("Inode: "=tmpFileInfo$,1,1)+7,pos("Links"=tmpFileInfo$,1,1)-1-(pos("Inode: "=tmpFileInfo$,1,1)+7))
             fst$(15,4)=bin(num(inode$))

                          rem TODO: 19-20 File protection bits             
             numLinks$=tmpFileInfo$(pos("Links: "=tmpFileInfo$)+len("Links: "))
             fst$(23,2)=bin(num(numLinks$))
             continue
            endif 

                        if pos("Uid:"=tmpFileInfo$)>0 then 
                fileType$=tmpFileInfo$(pos("/"=tmpFileInfo$,1,1)+1,1)
                switch 1 
                case fileType$="d";fst$(21,2)=$000A$;break 
                rem TODO: System File
                case fileType$="b";fst$(21,2)=$0040$;break
                case fileType$="c";fst$(21,2)=$0041$;break
                case fileType$="p";fst$(21,2)=$0042$;break
                rem UNIX Network Special
                case fileType$="s";fst$(21,2)=$0044$;break  
                case fileType$="l";fst$(21,2)=$0045$;break   
                case default;fst$(21,2)=$004F$;break 
                swend

                                uid$=tmpFileInfo$(pos("("=tmpFileInfo$,1,2)+1,pos("/"=tmpFileInfo$,1,2)-(pos("("=tmpFileInfo$,1,2)+1))
                fst$(25,2)=bin(num(uid$)) 

                                gid$=tmpFileInfo$(pos("("=tmpFileInfo$,1,3)+1,pos("/"=tmpFileInfo$,1,3)-(pos("("=tmpFileInfo$,1,3)+1))
                fst$(27,2)=bin(num(gid$)) 

                                rem todo: Device ID. This entry is valid only for Block and character special devices
                fst$(29,4)=$00000000$
                continue 
            endif 
            if pos("Size:"=tmpFileInfo$,1,1)>0 and pos("Uid"=tmpFilePos$,1,1)=0 then 
                fileSize$=tmpFileInfo$(pos("Size:"=tmpFileInfo$,1,1)+6,pos("Blocks:"=tmpFileInfo$,1,1)-(pos("Size:"=tmpFileInfo$,1,1)+6))
                fst$(33,4)=bin(num(cvs(fileSize$,16)))
            endif 

                        if pos("Change:"=tmpFileInfo$,1,1)>0 then 
                changed$=tmpFileInfo$(9,20) 
                fst$(37,6)=bin(round(TB.DTN(changed$,"YYYY-MM-DD HH:MI:SS"),0))
                continue 
            endif 

                        if pos("Access:"=tmpFileInfo$,1,1)>0 and pos("Uid:"=tmpFileInfo$,1,1)=0 then 
                changed$=tmpFileInfo$(9,20) 
                fst$(43,6)=bin(round(TB.DTN(changed$,"YYYY-MM-DD HH:MI:SS"),0))
                continue 
            endif 

                    wend 
        close(ch) 

                methodret fst$+filePath$
        FSTError:
        System.out.println("Error FSTs"+str(err)+" "+str(tcb(5)))
        methodret ""
      methodend 

      method public BBjString DSD(BBjString in$) 
        seterr DSDError
        dim dsd$(150) 

        config$=BBjApi().getConfig().getConfigFileName()
        ch=unt 
        open(ch)"|/bin/cat "+config$+" | grep "+in$
        read(ch,end=*next)dAlias$
        if pos(" "+in$+" "=dAlias$,1,1)=0 then dAlias$="" endif 
        close(ch)


        dsd$(1,3)=in$;rem hta(fid(0))

                switch 1 
        case in$(1,1)="T"
            dsd$(4,1)="T"
            dsd$(5,1)=$00$
            dsd$(6,1)=$00$
            dsd$(11,8) = STBL("!ID_TERM")
            break 
        case in$(1,1)="P" 
            dsd$(4,1)="P"
            dsd$(5,1)=$09$
            if pos("lp -d"=dAlias$,1,1)>0 then dsd$(6,1)=$01$ endif 
            if pos("/dev/tty"=dAlias$,1,1)>0 then dsd$(6,1)=$02$ endif 
            break
        case in$(1,1)="D"
            dsd$(23,64) = STBL("!DSK_"+cvs(in$,3))    
            break
        case default
            dsd$(5,1)=$00$
            dsd$(6,1)=$00$
            break 
        swend




        rem dsd 7,47 - DOS 
        methodret dsd$
        DSDError:
        System.out.println("Error DSD"+str(err)+" "+str(tcb(5)))
        methodret ""
      methodend 


    classend

        class public LinuxFileInfo 

                field private BBjString filePath$
        field private BBjString device$ 
        field private BBjNumber inode
        field private BBjNumber numLinks
        field private BBjString fileType$
        field private BBjNumber uid 
        field private BBjNumber gid 
        field private BBjNumber fileSize 
        field private BBjNumber lastChange
        field private BBjNumber lastAccess

                method private LinuxFileInfo() 
        methodend 

        method public LinuxFileInfo(BBjString file$)
        seterr LinuxFileInfoError
        rem *nix OS 
        ch=unt 
        open(ch)"| /usr/bin/stat "+file$ 
        while 1 
            read(ch,end=*break)tmpFileInfo$ 

            if pos("File:"=tmpFileInfo$,1,1)>0 and pos("->"=tmpFileInfo$,1,1)>0 then 
                #filePath$=tmpFileInfo$(pos("`"=tmpFileInfo$,1,2)+1,pos("'"=tmpFileInfo$,1,2)-(pos("`"=tmpFileInfo$,1,2)+1))
                continue
            endif 

                        rem device infomation 
           if tmpFileInfo$(1,6)="Device" then 
             device$=tmpFileInfo$(pos(" "=tmpFileInfo$,1,1)+1,pos("/"=tmpFileInfo$,1,1)-pos(" "=tmpFileInfo$,1,1)-2)
             #device$=fill(8-len(device$),"0")+device$

                          inode$=tmpFileInfo$(pos("Inode: "=tmpFileInfo$,1,1)+7,pos("Links"=tmpFileInfo$,1,1)-1-(pos("Inode: "=tmpFileInfo$,1,1)+7))
             #inode=num(inode$)

                          rem TODO: 19-20 File protection bits             
             numLinks$=tmpFileInfo$(pos("Links: "=tmpFileInfo$)+len("Links: "))
             #numLinks=num(numLinks$)
             continue
            endif 

                        if pos("Uid:"=tmpFileInfo$)>0 then 
                #fileType$=tmpFileInfo$(pos("/"=tmpFileInfo$,1,1)+1,1)

                                uid$=tmpFileInfo$(pos("("=tmpFileInfo$,1,2)+1,pos("/"=tmpFileInfo$,1,2)-(pos("("=tmpFileInfo$,1,2)+1))
                #uid=num(uid$)

                                gid$=tmpFileInfo$(pos("("=tmpFileInfo$,1,3)+1,pos("/"=tmpFileInfo$,1,3)-(pos("("=tmpFileInfo$,1,3)+1))
                #gid=num(gid$)

                                rem todo: Device ID. This entry is valid only for Block and character special devices
                continue 
            endif 
            if pos("Size:"=tmpFileInfo$,1,1)>0 and pos("Uid"=tmpFilePos$,1,1)=0 then 
                fileSize$=tmpFileInfo$(pos("Size:"=tmpFileInfo$,1,1)+6,pos("Blocks:"=tmpFileInfo$,1,1)-(pos("Size:"=tmpFileInfo$,1,1)+6))
                #fileSize=num(cvs(fileSize$,16))
            endif 

            if pos("Change:"=tmpFileInfo$,1,1)>0 then 
                changed$=tmpFileInfo$(9,20) 
                #lastChanged=round(TB.DTN(changed$,"YYYY-MM-DD HH:MI:SS"),0)
                continue 
            endif 

                        if pos("Access:"=tmpFileInfo$,1,1)>0 and pos("Uid:"=tmpFileInfo$,1,1)=0 then 
                changed$=tmpFileInfo$(9,20) 
                #lastAccess=round(TB.DTN(changed$,"YYYY-MM-DD HH:MI:SS"),0)
                continue 
            endif 
            methodret 
            LinuxFileInfoError:
            System.out.println("Error DSD"+str(err)+" "+str(tcb(5)))
        methodend 

                method public BBjString getFilePath() 
            methodret #filePath$
        methodend 

                method public BBjString getDevice() 
            methodret #device$ 
        methodend 

                method public BBjNumber getInode() 
            methodret #inode
        methodend 

                method public BBjNumber getNumLinks() 
            methodret #numLinks
        methodend 

                method public BBjString getFileType() 
            methodret #fileType$
        methodend 

                method public BBjNumber getUID() 
            methodret #uid
        methodend 

                 method public BBjNumber getGID() 
            methodret #gid
        methodend 

                 method public BBjNumber getFileSize() 
            methodend #fileSize
        methodend 

                 method public BBjNumber getLastChange() 
            methodret #lastChange
        methodend 

                method public BBjNumber getLastAccess() 
            methodret #lastAccess
        methodend 

         classend 