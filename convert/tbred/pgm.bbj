REM /**
REM  * pgm.bbj
REM  * @author atimm
REM  *
REM  */
use java.util.regex.Pattern
use java.util.regex.Matcher
use java.util.LinkedHashMap
use org.apache.commons.lang3.StringUtils
use java.lang.reflect.Array



class public PgmLine

    field public String pgmLine! 
    field public BBjVector statements! 

        method private PgmLine() 
    methodend 

        method public PgmLine(String pgmLine!) 
    seterr createLine 

        if pgmLine!<>null() and pgmLine!.length()>0 then 
        #statements! = bbjapi().makeVector()
        #pgmLine! = pgmLine!.replaceAll("REM\ *?""","REM """"")
        #splitLine()
        #pgmLine! = #pgmLine!.replaceAll("REM\ """"","REM """)
    endif 
    methodret 
    createLine: 
     throw "error create line "+str(tcb(5))+"/"+str(pgm(-1)),255 
    methodend

        method private void splitLine() 
        #statements! = bbjapi().makeVector()
        declare Pattern p!     
        p! = Pattern.compile("(?i:^\d{1,5}|\bIF\b|THEN|\bOR\b|\bAND\b|\bELSE\b|\;|$)(?=(?:(?:[^""]*""){2})*[^""]*$)")
        declare Matcher m!
        m! = p!.matcher(#pgmLine!)
        startline=0 
        while m!.find() 
            statement! = #pgmLine!.substring(startline,m!.end()) 

                        if cvs(statement!,3)=m!.group() then 
                #statements!.add(m!.group().trim())
            else     
                #statements!.add(statement!.substring(0,statement!.length()-m!.group().length()).trim())
                #statements!.add(m!.group().trim())
            endif 
            startLine=m!.end() 
        wend
    methodend 

   method public String getLine() 
        pgmLine! = ""
        for i=0 to #statements!.size()-1 
            pgmLine! = pgmLine!+#statements!.get(i).toString()+" "
        next i
        methodret pgmLine!
    methodend    

    method public String getBBjLine()
     seterr convertErr 
     declare String pgmLine! 
     declare String statement! 
     statement! = ""
     pgmLine! = ""

          for i=0 to #statements!.size()-1 
         statement! = #statements!.get(i).toString()

         rem if statement is line number goto ok 
         if statement!.matches("\d{1,}") then goto lineok endif 

         rem comments 
         rem don't convert lines that starts with comments 
         if statement!.trim().startsWith("REM ") then goto lineOk endif 
         rem enable line 
         if statement!.contains("<BBJ REM") then statement! = statement!.replaceAll("(\d{4,})\ *?REM","$1 ");goto lineOk endif 
         rem disable line 
         if statement!.contains(">BBJ REM") then statement! = statement!.replaceAll("(\d{4,})\ *?","$1 REM");goto lineOk endif 



         rem replace round brackets 
         if statement!.matches(".*?\(.*?\).*") then statement! = StringReplace.replaceRoundBrackets(statement!) endif 


         statement! = StringReplace.replaceENV(statement!)
         rem mode LINK - not used ORACLE 
         statement!=statement!.replaceAll("MODE\?=""LINK","MODE=""LINK") 
         statement!=statement!.replaceAll("ASC\ *?\(\ *?PGCHARBASE\ *?\)","dec(\$00\$+ath(stbl(""!PGCHARBASE"")))") 
         statement!=statement!.replaceAll("PGCHARBASE","STBL(""!PGCHARBASE"")")

         rem replace FINPUT by call 
         if statement!.contains("FINPUT") then statement! = StringReplace.replaceFInput(statement!) endif 

           rem replace open mode? mode shell with open on | 
         REM statement! = statement!.replaceAll("\,MODE\?\=""SHELL""\)","\)""\|""\+")   ;!.replaceAll("\,MODE\?\=""SHELL""(\,ERR\=\d*?)?(\))","$1$2\)""\|""\+") 
         statement! = statement!.replaceAll("\,MODE\?\=""SHELL""(\,ERR\=\d*)?(\)?)","$1$2\)""\|""\+") .replaceAll("\)\)\""","\)\""") 


        rem raplce ALL """" 
        statement! = statement!.replaceAll("(.*?)(?:\=|<|\>|\<\>)\ *?(\bALL\b)(.*)","TB.ALLBBj($1,$3)")

        rem replace insert array 
        if statement!.startsWith("INSERT") then statement! = StringReplace.replaceArray(statement!,"INSERT") endif 
        rem replace delete array 
        if statement!.startsWith("DELETE") then statement! = StringReplace.replaceArray(statement!,"DELETE") endif 

        rem replace CVT 
        statement! = StringReplace.replaceCVT(statement!)

           rem replace like with TB.LIKE 
        if statement!.matches(".*?LIKE.*") then statement! = StringReplace.replaceLike(statement!) endif 

        rem replace WindowShape 
        if statement!.matches(".*?WINDOW.*?SHAPE.*") then statement! = StringReplace.replaceWindowShape(statement!)  endif 

        rem replace SYSTEM with scall 
        if statement!.matches(".*\bSYSTEM\b.*") then statement! = StringReplace.replaceSystem(statement!) endif

        rem replace ADDSORT 
        if statement!.contains("ADDSORT") then statement!=StringReplace.replaceAddSort(statement!) endif 
        rem replace REMSORT 
        if statement!.contains("REMSORT") then statement!=StringReplace.replaceRemSort(statement!) endif 
        rem replace RENAME 
        if statement!.contains("RENAME") then statement!=StringReplace.replaceRename(statement!) endif 

        rem replace GETSCREEN
        if statement!.matches(".*WIN\?\(GET\ *?SCREEN\).*") then 
            statement! = statement!.replaceAll("(LET\ *?)(.*?\$)\ *?\=\ *?(WIN\?\(GET\ *?SCREEN\)?)(\,ERR\=\d{4,}|\;|$)","CALL ""DB%WIN"",""GETSCREEN"",$2$4")
        endif 

        rem replace GET ROW 
        if statement!.matches(".*?WIN\?\(GET\ *?ROW\ *?\,.*") then 
            statement!= statement!.replaceAll("(LET\ *?)(.*?\$)\ *?\=\ *?(WIN\?\(GET\ *?ROW\ *?\,(.*?)\)?)(\,ERR\=\d{4,}|\;|$)","CALL ""DB%WIN"",""GETROW"",$4$5")
        endif 

        rem replace GET CHAR 
        if statement!.matches(".*?WIN\?\(GET\ *?CHAR\ *?\,.*") then 
            statement!= statement!.replaceAll("(LET\ *?)(.*?\$)\ *?\=\ *?(WIN\?\(GET\ *?CHAR\ *?\,(.*?)\)?)(\,ERR\=\d{4,}|\;|$)","CALL ""DB%WIN"",""GETCHAR"",$4$5")
        endif 

        rem replace WIN GET 
        if statement!.matches(".*?WIN\?\(GET\ *?\).*") then 
            statement! = statement!.replaceAll("(LET\ *?)(.*?\$)\ *?\=\ *?(WIN\?\(GET\ *?\))(\,ERR\=\d{4,}|\;|$)","CALL ""DB%WIN"",""GET"",$2$4")
        endif  

                rem repalce WINDOW PUT COLOR 
        if statement!.matches(".*?WINDOW\ *?PUT\ *?COLOR\ *?\((.*?)\).*") then 
            statement!=statement!.replaceAll("WINDOW\ *?PUT\ *?COLOR\ *?\((.*?)\)(\,ERR\=\d{4,}|\;|$)","CALL ""DB%WIN"",""PUTCOLOR"",$1$2")
        endif 

                rem replace WINDOW PUT
        if statement!.matches(".*?WINDOW\ *?PUT\ *?\((.*?)\).*") then 
            statement!=statement!.replaceAll("WINDOW\ *?PUT\ *?\((.*?)\)(\,ERR\=\d{4,}|\;|$)","CALL ""DB%WIN"",""PUT"",$1$2")
        endif 

                rem repalce WINDOW PUT ATTR CHAR 
        if statement!.matches(".*?WINDOW\ *?PUT\ *?ATTR\ *?CHAR\ *?\((.*?)\).*") then 
            statement!=statement!.replaceAll("WINDOW\ *?PUT\ *?ATTR\ *?CHAR\ *?\((.*?)\)(\,ERR\=\d{4,}|\;|$)","CALL ""DB%WIN"",""PUTATTR"",$1$2")
        endif 

                rem repalce WINDOW PUT CHAR 
        if statement!.matches(".*?WINDOW\ *?PUT\ *?CHAR\ *?\((.*?)\).*") then 
            statement!=statement!.replaceAll("WINDOW\ *?PUT\ *?CHAR\ *?\((.*?)\)(\,ERR\=\d{4,}|\;|$)","CALL ""DB%WIN"",""PUTCHAR"",$1$2")
        endif 
        
                rem replace get CURSOR PHY 
        if statement!.matches(".*?WIN\ *?\(GET\ *?CURSOR\ *?\,\ *?PHYSICAL\ *?\).*") then 
            statement! = statement!.replaceAll("(LET\ *?)(.*?\$)\ *?\=\ *?(WIN\ *?\(GET\ *?CURSOR\ *?\,\ *?PHYSICAL\ *?\))(\,ERR\=\d{4,}|\;|$)","CALL ""DB%WIN"",""GETCURSORPHYSICAL"",$2$4")                                   
        endif 

                rem replace get CURSOR  
        if statement!.matches(".*?WIN\(GET\ *?CURSOR\ *?\).*") then 
            statement! = statement!.replaceAll("(LET\ *?)(.*?\$)\ *?\=\ *?(WIN\(GET\ *?CURSOR\ *?\))(\,ERR\=\d{4,}|\;|$)","CALL ""DB%WIN"",""GETCURSOR"",$2$4")                                   
        endif 

                REM make sure there is a , after print ATTR
        statement! = statement!.replaceAll("(PRINT\ *?'ATTR'\ *?\(.*?\))(?!\,)(.*?)(\;|$)","$1,$2$3") 

                rem replace close(0) 
        statement! = statement!.replaceAll("CLOSE\ *?\(\ *?0\ *?\)","TB.closeAll\(\)")  

                rem replace DEV 
        statement! = statement!.replaceAll("(OPEN\ *?\(.*?\,)(DEV\=)(.*?)(\,|\))","$1MODE=""PTON=""+HTA($3)+\$0D\$$4").replaceAll("(OPEN.*?MODE\=\""PTON\=\""\+HTA\(.*?\).*?\))(.*?)(\;|$)","$1""LRA""$3")

                rem can use opt as variable replace mode?= by opt= 
        statement! = statement!.replaceAll("MODE\?\=","OPT\=") 

                rem replace DSK system var but not in REPDSK method 
        statement! = statement!.replaceAll("(?<=\=\ )(DSK)(?=(?:(?:[^""]*""){2})*[^""]*$)","TB.REPDSK(DSK)") 

                REM REPLACE WINDOW 
        rem replace WIN GET LIST 
        statement! = StringReplace.replaceWinGet(statement!) 
        rem replace WIN GET INFO 
        statement! = StringReplace.replaceWinGetInfo(statement!) 

        escape
                REM replace WINDOW DELETE 
        statement! = statement!.replaceAll("(?i)WINDOW\ *?DELETE\ *?\((ALL)\)","CALL ""DB%WIN"",""DELETE"",""$1""")
        statement! = statement!.replaceAll("WINDOW\ *?DELETE\ *?\((.*?)\)","CALL ""DB%WIN"",""DELETE"",$1")

                rem replace String DSK 
        if statement!.matches(".*?\bSTRING\b.*?") then statement! = statement!.replaceAll("(STRING\ *?)(\w+.*?)\,(.*?)(\,0)","$1 TB.REPDSK\($3\)+$2") endif

                rem replace param
        statement! = statement!.replaceAll("ARGV\(ARGC-1\)","STBL\(""!IPL"",ERR=\*next\)")  
        statement! = statement!.replaceAll("ARGV\(2\)","STBL\(""!IPL"",ERR=\*next\)") 

                rem replace SEP by SEP$ 
        statement! =statement!.replaceAll("\bSEP\b(?!\$)","SEP\$") 

                rem remove err in START 
        statement!=statement!.replaceAll("(START\ *?\d{1,})(,ERR=\d{4,}\,)","$1,")  

                rem remove END= in remove 
        statement!=statement!.replaceAll("(REMOVE\ .*?),END=\d{4,}","$1") 


                rem replace RELEASE another session killSEssion 
        statement! = statement!.replaceAll("(RELEASE\ *?)(\w.*?)(\;|$)","TB.killSession($2)$3") 

                rem 
        if statement!.matches(".*(\bINDEXED\b|\bSORT\b|\bDIRECT\b|\bVKEYED\b)\ *?.*?\,.*?\,.*?,.*?\,.*?(\;|$).*") then call "replace.bbj::handleFileCreate",statement! endif 

        rem replace socket 
        if statement!.matches("OPEN.*?SOCKET.*") then statement!=statement!.replaceAll("(OPEN.*?)(\,OPT=\""SOCKET\"")(.*?\))(.*)","$1,MODE=TB.SOCKET\($4\)$3\""N0\""")


        rem raplce IFF47
        rem statement!=StringReplace.replaceIFF47(statement!)

                REM rem handle num with NTP and SIZ
        REM statement! = statement!.replaceAll("(LET.*?)(\,NTP\=0\,SIZ\=\.01\))","_precision=tcb(14);PRECISION 2;$1\);PRECISION _precision")

                statement! = StringReplace.replaceCallTailingSpaces(statement!)
        REM replace DOM -> ERR in call 
        statement! = statement!.replaceAll("(CALL\ *?.*?\,)DOM\=","$1ERR=")  

                

        lineOk: 
         pgmLine! = pgmLine!+statement!+" "
     next i
     
     pgmLine!=StringReplace.replaceIFF47(pgmLine!)
     
     methodret CPL(pgmLine!)
     convertErr: 
     methodret CPL(#autoFix(pgmLine!),err=*next)
     methodret #pgmLine!
    methodend 
    
    method public String autoFix(String z!) 
        rem try auto fix 
        if z!.matches(".*(\,\ *?ERR\=(\d{4,}||w+)\ *$)") then 
            z!=z!.replaceAll("(\,\ *?ERR\=(\d{4,}|w+)\ *$)","")
       endif
       methodret z!
    methodend 
    

classend 

class public StringReplace

        method public static boolean matchesKeyword(String keyword!)
        declare LinkedHashMap keyWordMap! 
        keyWordMap! = new LinkedHashMap()
        keyword! = keyword!.toUpperCase()

        keyWordMap!.put("FILL","") ; keyWordMap!.put("CLOSE","");keyWordMap!.put("WRITE","");keyWordMap!.put("STBL","")
        keyWordMap!.put("JUL","");keyWordMap!.put("LOCK","");keyWordMap!.put("UNLOCK","");keyWordMap!.put("ERASE","")
        keyWordMap!.put("TBL","");keyWordMap!.put("IF","")
        keyWordMap!.put("INPUT",""); keyWordMap!.put("FINPUT",""); keyWordMap!.put("READ","") ; keyWordMap!.put("EXTRACT",""); keyWordMap!.put("PREAD","")
        keyWordMap!.put("PEXTRACT",""); keyWordMap!.put("RECORD",""); keyWordMap!.put("OPEN",""); keyWordMap!.put("REMOVE",""); keyWordMap!.put("PRINT","") 
        keyWordMap!.put("KEYL","");keyWordMap!.put("KEYF","");keyWordMap!.put("KEYN","");keyWordMap!.put("KEYP","")

        keyWordMap!.put("INFO","")
        keyWordMap!.put("WINDOW","")
        keyWordMap!.put("SHAPE","") 
        keyWordMap!.put("WIN","")
        keyWordMap!.put("GETINFO","")
        keyWordMap!.put("SEVAL","")
        keyWordMap!.put("MIN","")
        keyWordMap!.put("MAX","")
        keyWordMap!.put("AND","")
        keyWordMap!.put("OR","")
        keyWordMap!.put("COLOR","")
        keyWordMap!.put("CHAR","")
        keyWordMap!.put("PUT","")
        keyWordMap!.put("ERRMES","")
        keyWordMap!.put("POS","")
        keywordMap!.put("REM","")
        keywordMap!.put("WHILE","")
        keywordMap!.put("DIR","")
        keywordMap!.put("XOR","")
        keywordMap!.put("DELETE","") 

        keyWordMap!.put("ABS","") ; keyWordMap!.put("ACS","") ; keyWordMap!.put("ASC","") ; keyWordMap!.put("ASN","") ; keyWordMap!.put("ATN","") ; keyWordMap!.put("ATQ","") 
        keyWordMap!.put("BSZ","") ; keyWordMap!.put("COS","") ; keyWordMap!.put("DEC","") ; keyWordMap!.put("DTN","") ; keyWordMap!.put("EPT","") ; keyWordMap!.put("ERR","")
        keyWordMap!.put("EXP","") ; keyWordMap!.put("FIX","") ; keyWordMap!.put("FPT","") ; keyWordMap!.put("IND","") ; keyWordMap!.put("INT","") ; keyWordMap!.put("LEN","") 
        keyWordMap!.put("LOG","") ; keyWordMap!.put("MAX","") ; keyWordMap!.put("MIN","") ; keyWordMap!.put("MOD","") ; keyWordMap!.put("NEA","") ; keyWordMap!.put("NLG","")
        keyWordMap!.put("NMV","") ; keyWordMap!.put("NUM","") ; keyWordMap!.put("RND","") ; keyWordMap!.put("SGN","") ; keyWordMap!.put("SIN","") 
        keyWordMap!.put("SQR","") ; keyWordMap!.put("SSZ","") ; keyWordMap!.put("STL","") ; keyWordMap!.put("TAN","") ; keyWordMap!.put("TCB","") ; keyWordMap!.put("UNT","") 
        keyWordMap!.put("AND","") ; keyWordMap!.put("ARG","") ; keyWordMap!.put("ATH","") ; keyWordMap!.put("ATR","") ; keyWordMap!.put("BIN","") ; keyWordMap!.put("CGV","") 
        keyWordMap!.put("CHR","") ; keyWordMap!.put("CPL","") ; keyWordMap!.put("CPP","") ; keyWordMap!.put("CRC","") ; keyWordMap!.put("CVT","") ; keyWordMap!.put("DCM","") 
        keyWordMap!.put("DIM","") ; keyWordMap!.put("DSD","") ; keyWordMap!.put("DSK","") ; keyWordMap!.put("DTR","") ; keyWordMap!.put("ERM","") ; keyWordMap!.put("FID","")
        keyWordMap!.put("FKY","") ; keyWordMap!.put("FMD","") ; keyWordMap!.put("FMT","") ; keyWordMap!.put("FST","") ; keyWordMap!.put("GAP","") ; keyWordMap!.put("HSH","")
        keyWordMap!.put("HTA","") ; keyWordMap!.put("INF","") ; keyWordMap!.put("IOR","") ; keyWordMap!.put("KEY","") ; keyWordMap!.put("LKY","") ; keyWordMap!.put("LRC","") 
        keyWordMap!.put("LST","") ; keyWordMap!.put("MNE","") ; keyWordMap!.put("NOT","") ; keyWordMap!.put("NTD","") ; keyWordMap!.put("PAD","") ; keyWordMap!.put("PCK","") 
        keyWordMap!.put("PFL","") ; keyWordMap!.put("PFP","") ; keyWordMap!.put("PGM","") ; keyWordMap!.put("PKY","") ; keyWordMap!.put("PUB","") ; keyWordMap!.put("RTD","") 
        keyWordMap!.put("SDX","") ; keyWordMap!.put("STR","") ; keyWordMap!.put("SWP","") ; keyWordMap!.put("TBL","") ; keyWordMap!.put("TSK","") ; keyWordMap!.put("UCM","") 
        keyWordMap!.put("UPK","") ; keyWordMap!.put("WIN","") ; keyWordMap!.put("XFD","") 




REM         keyWordMap!.put("","") ;
REM         keyWordMap!.put("","") ;
REM         keyWordMap!.put("","") ;
REM         keyWordMap!.put("","") ;
REM         keyWordMap!.put("","") ;

                if keyWordMap!.containsKey(keyword!.trim()) then methodret bbjapi().TRUE endif 

                   methodret bbjapi().FALSE
    methodend 

        rem  replace global vars like ]USER$ -> ENV_USER$   
    method public static String replaceENV(String z!)  
        z!=z!.replaceAll("\](?=\b\w+)\b","_")    
        REM replace QUO WITH """ 
        z!=z!.replaceAll("(?<=\+)QUO|QUO(?=\+)|(?<=\+)QUO(?=\+)","""") 
        methodret z!
    methodend


    REM /* 
    REM / replaces round brackets by [] for 
    REM */
    method public static String replaceRoundBrackets(String z!) 
        seterr replaceBracketsError
        declare Pattern p! 
        seterr 0
REM     p! = Pattern.compile("\w+(\ *\()")
        p! = Pattern.compile("(\w+\ *?\()(?=(?:(?:[^""]*""){2})*[^""]*$)")
       rem  \b\w+\ *?(\()(?=(?:(?:(?:[^""\\]++|\\.)*+""){2})*+(?:[^""\\]++|\\.)*+$)")
        declare Matcher m!
        m! = p!.matcher(z!)
        declare String keyword! 
        while m!.find() 
        keyword! = m!.group(0)
        keyword! = keyword!.substring(0,keyword!.length()-1).trim()  
        rem check for methods 
        if m!.start()>0 then if z!.substring(m!.start()-1,m!.start())="." then continue endif endif
        rem check for templates 
        if m!.start()>0 then if z!.substring(m!.start()-1,m!.start())=":" then continue endif endif

        rem check for custom functions 
        if keyword!.startsWith("FN") then continue endif 
        rem except for ARGV
        if keyword!.startsWith("ARGV") then continue endif 
        if StringReplace.matchesKeyword(keyword!) then continue endif 
REM         System.out.println("word:"+m!.toString())        
        posClosingBracket=z!.indexOf(")",m!.start());if posClosingBracket=-1 then methodret z! endif 
        rem don't convert it String does not contain closing bracket 
        if closingBracket=-1 then methodret z! endif 
        if posClosingBracket=z!.length() then endline=z!.length() else endline=posClosingBracket+1 endif
        posBracket = z!.indexOf("(",m!.start())

                rem check for openning brackets between the opening and the first closing one 
        noOpeningBrackets = StringUtils.countMatches(z!.substring(posBracket,posClosingBracket),"(")  

        if noOpeningBrackets>0 then 
            tmp$=z!.substring(m!.start()) 
            posClosingBracket=m!.start()+pos(")"=tmp$,1,noOpeningBrackets)-1
        endif            

           z! = z!.substring(0,m!.start())+keyword!+"["+z!.substring(posBracket+1,posClosingBracket)+"]"+z!.substring(posClosingBracket+1)
        wend
        methodret z!
        replaceBracketsError: 
          if pos("StringIndexOutOfBoundsException"=errmes(-1)) >0 then System.out.println(z!);methodret z! 
    methodend 


    REM /*
    REM *
    REM *  replace string = INSERT ARRAY call "TBUTILS.bbj::INSERTARRAY",ARRAY[ALL],options
    REM * 
    REM */ 
    method public static String replaceArray(String z!,String function!) 
        seterr replaceArrayError
        declare String newLine! 
        newLine! = new String("") 
        declare Pattern p!     
        p! = Pattern.compile("((?i)"+function!+"\ ARRAY\ ?(.*?))\[\((.*?)(\)\])(\;|$)")
        declare Matcher m!
        m! = p!.matcher(z!)

        declare String beginLine!
        declare String endLine!  
        beginLine! = new String("") 
        endLine! = new String("") 
        startLine=0
        while m!.find() 
            beginLine! = z!.substring(startLine,m!.start(1))
            endline! = z!.substring(m!.end(4))
            arrayname$=m!.group(2)
            arrayType$="N"
            if arrayname$(len(arrayname$),1)="$" then arrayType$="S" endif
REM             dim x![1]
            tmp$ = m!.group(3) 
REM             tmp! = tmp!.replaceAll("\,((.)(?<!\()(?!\)))",",$1$1")
REM             x![]=tmp!.split("\,(.(?<!\()(?!\)))")
            ok=1
            posChar=0
            for i=1 to len(tmp$)
                if tmp$(i,1)="(" then ok=0;continue 
                if tmp$(i,1)=")" then ok=1;continue 
                if ok and tmp$(i,1)="," then posChar=i;break
            next i 
            newLine! = newLine!+beginLine!+" call ""DB%"+arrayType$+"ARRAY"","""+function!+""","+arrayname$+"[ALL],"+tmp$(1,i-1)+","+tmp$(i+1)
            startLine=m!.end(4)
        wend
            if newLine!.isEmpty() then methodret z! endif 
            newLine!=newLine!+endLine!
            methodret newLine!
    replaceArrayError: 
    rem donoting         
    methodret z! 
    methodend 

    REM /*
    REM *
    REM *  replace like
    REM * 
    REM */ 
    method public static String replaceLike(String z!) 
        seterr replaceLikeError
        declare String newLine! 
        newLine! = new String("") 
        declare Pattern p!     
     
        p! = Pattern.compile("(.*?)((?i)\ *?\bLIKE\ *?)(.*(\)|\""|\$))")       
        declare Matcher m!
        m! = p!.matcher(z!)

        declare String beginLine!
        declare String endLine!  
        beginLine! = new String("") 
        endLine! = new String("") 
        startLine=0

        while m!.find() 
                
            beginLine! = z!.substring(startLine,m!.start(1))
            endline! = z!.substring(m!.end(3))
            newLine! = newLine!+beginLine!+" TB.LIKE("+m!.group(1).trim()+","+m!.group(3).trim()+") "
            startLine=m!.end(3)
        wend
            if newLine!.isEmpty() then methodret z! endif 
            newLine!=newLine!+endLine!
REM             System.out.println(z!)
            methodret newLine!
    replaceLikeError: 
    rem donoting         
    methodret z! 
    methodend 

    rem /* 
    rem * replace WINDOW SHAPE (LINE,HORIZONTAL,0,1,33) ""BORDERATR=BG"""
    rem * CALL "DB%WINSHAP","LINE",0,0,1,33,"BORDERATR=BG"
    rem * only works with one occurrence per line 
    rem */
    method public static String replaceWindowShape(String z!) 
        seterr replaceWindowShapeError
        declare String newLine! 
        newLine! = new String("") 
        declare Pattern p!     
        
        p! = Pattern.compile("(WINDOW\ *SHAPE)\ *?\((.*)\)(.*)")

        declare Matcher m!
        m! = p!.matcher(z!)

        declare String beginLine!
        declare String endLine!  
        beginLine! = new String("") 
        endLine! = new String("") 
        startLine=0

                while m!.find() 
            beginLine! = z!.substring(startLine,m!.start(1))
            endline! = z!.substring(m!.end(3))
            HV=-1
            
            declare BBjVector vec! 
            vec! = #splitExpression(m!.group(2)) 
            
            if vec!.getItem(1)="HORIZONTAL" then HV=0 endif 
            if vec!.getItem(1)="VERTICAL" then HV=1 endif
            if vec!.getItem(0)="LINE" or vec!.getItem(0)="BOX" then 
                item0$=""""+vec!.getItem(0)+""""
            else 
                item0$=vec!.getItem(0)
            endif 
            
            if HV=-1 then 
                newLine! = newLine!+beginLine!+" CALL ""DB%WINSHAP"","+item0$+","+vec!.getItem(1)+","+vec!.getItem(2)+","+vec!.getItem(3)+","+vec!.getItem(4)+","+m!.group(3)
            else 
                newLine! = newLine!+beginLine!+" CALL ""DB%WINSHAP"","+item0$+","+str(hv)+","+vec!.getItem(2)+","+vec!.getItem(3)+","+vec!.getItem(4)+","+m!.group(3)
            endif
            startLine=m!.end(3)
        wend
            if newLine!.isEmpty() then methodret z! endif 
            newLine!=newLine!+endLine!
REM             System.out.println(z!)
            methodret newLine!
    replaceWindowShapeError: 
    rem donoting         
    methodret z!     
    methodend 

    method public static String replaceFInput(String z!) 
        seterr replaceFInputError
        declare String newLine! 
        newLine! = new String("") 
        declare Pattern p!     
        if !z!.contains("FINPUT") then methodret z! endif 
        p! = Pattern.compile("(?:(EDT\=.*?)(\,|\))|(TIM\=.*?)(\,|\))|(ERR\=\d.*)(\,|\)))")
        declare Matcher m!
        m! = p!.matcher(z!)

        declare String beginLine!
        declare String endLine!  
        beginLine! = new String("") 
        endLine! = new String("") 
        startLine=0

        declare LinkedHashMap map! 
        map! = new LinkedHashMap()
        declare String tmp!
        tmp! = new String("")  
        while m!.find() 
              tmp! = m!.group(0) 
              map!.put(tmp!.substring(0,tmp!.indexOf("=")),tmp!.substring(tmp!.indexOf("=")+1,tmp!.length()-1))         
        wend
              newLine! = "CALL ""DB%FINPUT"","+"ERR="+str(map!.get("ERR"))+",COLN,LIGN,LONG_AFF,LONG_SAI,"
              if map!.containsKey("TIM") then 
                newLine! = newLine!+map!.get("TIM")+","
              else 
                newLine! = newLine!+"0,"
              endif
              if map!.containsKey("EDT") then 
                newLine! = newLine!+map!.get("EDT")+","
              else 
                newLine! = newLine!+""""","
              endif              
              newLine! = newLine!+"E$,FCT" 
        methodret newLine!
    replaceFInputError: 
    rem donoting         
    methodret z!     
    methodend 

    rem * 
    rem * replace ADDSORT
    rem */
    method public static String replaceAddSort(String z!) 
        seterr replaceADDSORTError
        declare String newLine! 
        newLine! = new String("") 
        declare Pattern p!     
        p! = Pattern.compile("(ADDSORT)\ (.*?)\,(.*?)\:(.*?)\,([\w\.\$\(\)\[\]\=\d\,\*\""\?\|\&\@\\\_\/\:\-\+]+)")
        declare Matcher m!
        m! = p!.matcher(z!)

        declare String beginLine!
        declare String endLine!  
        beginLine! = new String("") 
        endLine! = new String("") 
        startLine=0

        while m!.find() 
            beginLine! = z!.substring(startLine,m!.start(1))
            endline! = ""
            keyString!=m!.group(4) 
            keyString! = keyString!.replaceAll("""","""""")            
            newLine! = newLine!+beginLine!+"TB.ADDSORT(TB.REPDSK("+m!.group(5)+")+"+m!.group(2)+","+m!.group(3)+","""+keyString!+""")"
            if z!.substring(m!.end(5)).indexOf(";")>-1 then endLine=m!.end(5) endif 
            startline=m!.end(5)
            wend
            if newLine!.isEmpty() then methodret z! endif 
            if endline>0 then endline! = z!.substring(endline) endif
            newLine!=newLine!+endLine!
            methodret newLine!
    replaceADDSORTError: 
    rem donoting         
    methodret z!     
    methodend 

           rem * 
    rem * replace REMSORT
    rem */
    method public static String replaceRemSort(String z!) 
        seterr replaceREMSORTError
        declare String newLine! 
        newLine! = new String("") 
        declare Pattern p!     
        p! = Pattern.compile("(REMSORT)\ (.*?)\,(?:KNUM\=)([\w\.\$\(\)\[\]\=\d\*\""\,\?\|\&\@\\\_\/\:\-\+]+)")
        declare Matcher m!
        m! = p!.matcher(z!)

        declare String beginLine!
        declare String endLine!  
        beginLine! = new String("") 
        endLine! = new String("") 
        startLine=0

                while m!.find() 
            beginLine! = z!.substring(startLine,m!.start(1))
            endline! = ""
            newLine! = newLine!+beginLine!+"TB.REMSORT("+m!.group(2)+","+m!.group(3)+")"
            if z!.length()>=m!.end(3) then endline=m!.end(3) endif 
            startline=m!.end(3)
        wend
            if newLine!.isEmpty() then methodret z! endif 
            if endline>0 then endline! = z!.substring(endline) endif
            newLine!=newLine!+endLine!
            methodret newLine!
    replaceREMSORTError: 
    rem donoting         
    methodret z!     
    methodend 


          rem * 
    rem * replace rename
    rem */
    method public static String replaceRename(String z!) 
        seterr replaceRenameError
        declare String newLine! 
        m_error$=CPL(z!,err=*next);methodret z! 
        newLine! = new String("") 
        declare Pattern p!     
        p! = Pattern.compile("(RENAME)\ (.*?)(?:\;|$)")
        declare Matcher m!
        m! = p!.matcher(z!)

             declare String beginLine!
        declare String endLine!  
        beginLine! = new String("") 
        endLine! = new String("") 
        startLine=0

        declare BBjVector vec! 
        vec! = bbjapi().makeVector()

        while m!.find() 
            beginLine! = z!.substring(startLine,m!.start(1))
            endline! = ""

            vec! = #splitExpression(m!.group(2)) 
            newLine! = newLine!+beginLine!+"RENAME TB.REPDSK("+str(vec!.getItem(0))+")+"+str(vec!.getItem(1))+",TB.REPDSK("+str(vec!.getItem(0))+")+"+str(vec!.getItem(2))
            if z!.length()>=m!.end(2) then endline=m!.end(2) endif 
            startline=m!.end(2)
        wend
rem             if newLine!.isEmpty() then methodret z! endif 
            if endline>0 then endline! = z!.substring(endline) endif
            newLine!=newLine!+endLine!
            methodret newLine!
    replaceRenameError: 
    rem donoting         
    methodret z!     
    methodend 


        method public static String replaceSystem(String z!) 
        seterr replaceSystem
        declare String newLine! 
        newLine! = new String("") 
        declare Pattern p!     
        p! = Pattern.compile("(SYSTEM)\ (.*?)(\;|$)(?=(?:(?:[^""]*""){2})*[^""]*$)")
        declare Matcher m!
        m! = p!.matcher(z!)

        declare String beginLine!
        declare String endLine!  
        beginLine! = new String("") 
        endLine! = new String("") 
        startLine=0

                declare BBjVector vec! 
        vec! = bbjapi().makeVector()

                while m!.find() 
            beginLine! = z!.substring(startLine,m!.start(1))
            endline! = ""                           
            newLine! = newLine!+beginLine!+"dummy=scall("+m!.group(2)+")"
            if z!.length()>=m!.end(2) then endline=m!.end(2) endif 
            startline=m!.end(2)
        wend
            if newLine!.isEmpty() then methodret z! endif 
            if endline>0 then endline! = z!.substring(endline) endif
            newLine!=newLine!+endLine!
            methodret newLine!
    replaceSystem: 
    rem donoting         
    methodret z!     
    methodend 

    rem replace WIN

     method public static String replaceWinGet(String z!) 
        seterr replaceWinGetError
        declare String newLine! 
        newLine! = new String("") 
        declare Pattern p!     
        p! = Pattern.compile("(LET\ *?\w+?\$)\ *?\=\ *?(WIN\ *?\(GET\ LIST\))")

        declare Matcher m!
        m! = p!.matcher(z!)


        declare String beginLine!
        declare String endLine!  
        beginLine! = new String("") 
        endLine! = new String("") 
        startLine=0

        while m!.find() 
            beginLine! = z!.substring(startLine,m!.start(1))
            endline! = z!.substring(m!.end(2))
            wlst$=m!.group(1).replaceAll("LET","") 
            newLine! = beginLine!   +"CALL ""DB%WIN"",""GETLIST"","+wlst$
        wend
            if newLine!.isEmpty() then methodret z! endif 
            newLine!=newLine!+endLine!
            methodret newLine!
    replaceWinGetError: 
    rem donoting         
    methodret z!     
    methodend 

        method public static String replaceWinGetInfo(String z!) 
        seterr replaceWinGetInfoError
        declare String newLine! 
        newLine! = new String("") 
        declare Pattern p!     
        p! = Pattern.compile("(WINDOW\ GETINFO\ *?)\((.*?)\)(.*?)(?:\;|$)")

        declare Matcher m!
        m! = p!.matcher(z!)

        declare String beginLine!
        declare String endLine!  
        beginLine! = new String("") 
        endLine! = new String("") 
        startLine=0

        while m!.find() 
            beginLine! = z!.substring(startLine,m!.start(1))
            endline! = z!.substring(m!.end(3))
            expr$=m!.group(2)
            if ! m!.group(3).trim().isEmpty() then 
                expr$=m!.group(3)+","+expr$
            endif
            newLine! = beginLine!   +"CALL ""DB%WIN"",""GETINFO"","+expr$
        wend
            if newLine!.isEmpty() then methodret z! endif 
            newLine!=newLine!+endLine!
            methodret newLine!
    replaceWinGetInfoError: 
    rem donoting         
    methodret z!     
    methodend 


REM /*
    REM *
    REM *  replace string = IFF47 String$(x,y)="t" LEN(A$)>=50 AND A$(50,1)="t" TB.ALLBBJ(string,compareString)
    REM * 
    REM */ 
    method public static String replaceIFF47(String z!) 
        seterr replaceIFF47Error
        declare String newLine! 
        newLine! = new String("") 
        declare String returnLine!
        returnLine! = new String("")
        declare Pattern p!     
        p! = Pattern.compile("(?:\bIF\b)(.*?)(?:\bTHEN\b)")
        declare Matcher m!
        m! = p!.matcher(z!)

        declare String beginLine!
        declare String endLine!  
        beginLine! = new String("") 
        endLine! = new String("") 
        startLine=0
        declare String statement!
        statement! = "" 
        
            while m!.find() 
            statement! = m!.group(1)
            declare Pattern p1!     
            p1! = Pattern.compile("(\w+?\$\ *?\(.*)")
            declare Matcher m1!      
            m1! = p1!.matcher(statement!)
            declare String myStatement!
            myStatement! = ""
            beginZ! = z!.substring(startLine,m!.start(1))
            endZ! = z!.substring(m!.end(1))
            startLine=0

            declare String lenExp!

                while m1!.find()         
                beginLine! = statement!.substring(startLine,m1!.start(1))
                endline! = statement!.substring(m1!.end(1))
                st1! = m1!.group(1)   
                var! = st1!.replaceAll(".*?(\w+\$).*","$1")                                 

                rem find expression in () 
                content!=st1!.substring(st1!.indexOf(var!)+var!.length()) 
                posMatch=#findMatchingBracket(content!) 
                if posMatch=-1 then methodret z! endif 

                content!=content!.substring(1,posMatch-1)

                                vec! = #splitExpression(content!) 

                                lenExp! = new String("")
                for i=0 to vec!.size()-1 
                    lenExp! = lenExp!+vec!.getItem(i)+"+"
                next i  
                lenExp! = lenExp!.substring(0,lenExp!.length()-1) 

                myStatement! = " (LEN("+var!+")>="+lenExp!+" AND "+st1!+" ) "

                newLine! = newLine!+beginLine!+myStatement!
                startLine=m1!.end(1)
              wend    

                             returnLine! = returnLine!+beginZ!+newLine!+endLine!
              newLine!="" 
              startLine=m!.end(1)
        wend

            if returnLine!.isEmpty() then methodret z! endif 
            returnLine!=returnLine!+endZ!
            methodret returnLine!
    replaceIFF47Error: 
    rem donoting         
    methodret z! 
    methodend 

    method private static BBjNumber findMatchingBracket(String exp!) 
        exp$=exp! 
        if pos(")"=exp$)>0 then
            tmp$=exp$(1,pos(")"=exp$))
            anz=pos("("=tmp$,1,0)
            methodret pos(")"=exp$,1,anz) 
        endif 
        methodret -1
    methodend 

     method private static BBjVector splitExpression(String exp!) 
        declare BBjVector vec! 
        vec! = bbjapi().makeVector()
        declare String tmp!  
        tmp! = exp! 
        ok=0
        startExp=0
        for i=0 to tmp!.length()-1 
            tmp$=tmp!.substring(i,i+1) 
            if tmp$="(" or tmp$="[" then ok=ok+1;continue endif 
            if tmp$=")" or tmp$="]" then ok=ok-1;continue endif
            if tmp$="," and ok=0 then
             posChar=i
             vec!.add(tmp!.substring(startExp,posChar))
             startExp=posChar+1
            endif  
        next i 
        vec!.add(tmp!.substring(startExp))
        methodret vec!
    methodend 

    rem replace CVT by CVS 
    method public static String replaceCVT(String z!) 
        seterr replaceCVTError
        declare String newLine! 
        newLine! = new String("") 
        declare Pattern p!     
        p! = Pattern.compile("(CVT\()(.*?)(\ *?LIKE\b|\>|\=|\<|\<\>|\;|$)")



        declare Matcher m!
        m! = p!.matcher(z!)

        declare String beginLine!
        declare String endLine!  
        beginLine! = new String("") 
        endLine! = new String("") 
        startLine=0

        declare LinkedHashMap map! 
        map! = new LinkedHashMap() 
        map!.put("1","8") 
        map!.put("2","128") 
        map!.put("4","32") 
        map!.put("8","4096")  
        map!.put("16","4") 
        map!.put("32","16") 
        map!.put("128","2")                
        declare String expr!
        declare String var!
        declare String cvtexpr!
        declare BBjVector vec!
       
            while m!.find() 
            beginLine! = z!.substring(startLine,m!.start(1))
            endline! = z!.substring(m!.end(3))
            content!=m!.group(2)
            expr!=""
            vec!=#splitExpression(content!)
            
                        var! = vec!.getItem(0).toString()
            expr! = vec!.getItem(1).toString()
            expr! = expr!.substring(0,expr!.length()-1)
            ok=1 

                        dim exprT![1]

                                    if expr!.contains("+") then 
                exprT![]=expr!.split("\+") 
                exprT!=expr!.split("\+") 
                lenExpr=Array.getLength(exprT!) 
            else 
                exprT![0]=expr!
                lenExpr=1 
            endif 
            cvtexpr! = ""

                        for i=0 to lenExpr-1
                if map!.containsKey(exprT![i]) then 
                    cvtexpr!=cvtexpr!+map!.get(exprT![i])+"+" 
                else 
                    ok=0 
                    break
                endif 
            next i 

                        if ok then 
                cvtexpr!=cvtexpr!.substring(0,cvtexpr!.length()-1)
                newLine! = newLine!+beginLine!+"CVS("+var!+","+cvtexpr!+")"+m!.group(m!.groupCount())
                startLine=m!.end(m!.groupCount())
            else 
                newLine! = newLine!+beginLine!+"TB."+m!.group()     
                startLine=m!.end()
            endif 

                    wend
            if newLine!.isEmpty() then methodret z! endif 
            newLine!=newLine!+endLine!
            methodret newLine!
    replaceCVTError: 
    rem donoting         
    methodret z!     
    methodend 


     rem remove tailing spaces 
    method public static String replaceCallTailingSpaces(String z!) 
        seterr replaceCallTailingSpacesError
        declare String newLine! 
        newLine! = new String("") 
        declare Pattern p!     
        p! = Pattern.compile("(CALL\ *?)(\"".*?\"")")

        declare Matcher m!
        m! = p!.matcher(z!)

        declare String beginLine!
        declare String endLine!  
        beginLine! = new String("") 
        endLine! = new String("") 
        startLine=0

        while m!.find() 
            beginLine! = z!.substring(startLine,m!.start(1))
            endline! = z!.substring(m!.end(2))
            expr$=m!.group(2)
            expr$=expr$(2,len(expr$)-2)
            lenexpr=len(expr$) 
            expr$=cvs(expr$,2)
            lenblank=lenexpr-len(expr$)
            newLine! = newLine!+beginLine!+"CALL """+expr$+""""+fill(lenblank," ")
            startLine=m!.end(2)

                    wend
            if newLine!.isEmpty() then methodret z! endif 
            newLine!=newLine!+endLine!
            methodret newLine!
    replaceCallTailingSpacesError: 
    rem donoting         
    methodret z!     
    methodend 



    classend 


REM todo: if statement!.matches(".*(\bINDEXED\b|\bSORT\b|\bDIRECT\b|\bVKEYED\b)\ *?.*?\,.*?\,.*?,.*?\,.*?(\;|$).*") then call "replace.bbj::handleFileCreate",Z$ endif 



z$="01110 WINDOW DELETE (ALL)"
l! = new PgmLine(z$) 





?l!.getBBjLine()